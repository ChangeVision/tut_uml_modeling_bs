ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_structure_design]]
[%nonfacing]
== スコアの構造を図にする

[.lead]
ここからは、スコアを計算するのに使う要素と、要素同士の関連、ゲームを進める動作をモデル図を使って整理してみましょう。



=== ゲームスコアのオブジェクト図を描く

吟味したユースケース記述を参照しながら、実際のゲームの様子を具体的な要素を使って図に表してみることで、スコアの計算にはどんな要素があればよいか考えてみましょう。

具体的な要素とは、ボウリングでいえば、ゲームやその各フレーム、ピンの数、スコアやボーナスを指します。
このようなことを図で表すには「オブジェクト図（インスタンス図と呼ぶこともあります）」が向いています。


==== プロジェクトに設計モデルを追加する

まず、プロジェクトに設計モデルを追加しましょう。
ここで言う設計モデルは、設計用に作成するモデル図を格納する場所だと思ってください。

[TIP]
--
ここでいう設計とは、対象とする業務やサービスに必要となる構成要素を洗い出すことと、それらを使った振舞いを検討することだと考えておけばよいでしょう。
--

[[add_design_model]]
.プロジェクトに設計モデルを追加する
[sidebar]
--
. プロジェクトにモデルを追加する。
** 構造ツリー上で、プロジェクトを選択する。
** 右クリックしてポップアップメニューを開き、「モデルの追加＞モデル」を選択する（ <<add_design_model01>> ）。

[[add_design_model01]]
.プロジェクトにモデルを追加した
image::add_design_model01.png[{half-width}]


[start=2]
. 追加したモデルに名前をつける
** 構造ツリー上で、追加したモデルを選択した状態で、プロパティーの「ベース」タブを選択する。
** 「名前」を編集して「02_設計モデル」とする（ <<add_design_model02>> ）。

[[add_design_model02]]
.モデルに設計用のモデルとして名前をつけた
image::add_design_model02.png[{half-width}]
--

==== 設計モデルにオブジェクト図を追加する

ゲームスコアのオブジェクトが作られていく様子をオブジェクト図で表してみましょう。
{astah} で「オブジェクト図」を作成するときは「クラス図」を使います。

.ゲームスコアのオブジェクト図を追加する
--
. モデルにクラス図を追加する（ <<object00>> ）。

[[object00]]
.モデルにクラス図を追加する
image::object00.png[{three-quarters-width}]

[start=2]
. 追加した図を「ゲームスコアのオブジェクト図」とする（  <<object01>> ）。

[[object01]]
.「ゲームスコアのオブジェクト図」を追加する
image::object01.png[{half-width}]
--

==== ゲームのオブジェクトを作成する

ユースケース記述を読むと、「ゲーム」と「フレーム」のオブジェクトが必要そうです。
まず、ゲームを表すオブジェクトを追加しましょう。

.ゲームを表すオブジェクトを追加する
--
. パレットから「インスタンス仕様」を選択して、図に配置する（ <<instance01>> ）。

[[instance01]]
.「インスタンス仕様」を追加する
image::GSW-20210827-113704.png[{three-quarters-width}]

[start=2]
. 名前が「インスタンス仕様0」（数字は作るたびにつけられる）となっている。これを、具体的なゲームを表す名前に変える。ここでは「game1」とする（ <<instance02>> ）。
** これはこのオブジェクト図で表そうとしているゲームにつけた識別子。
** 名前の文字列を直接クリックして編集してもよいし、オブジェクトを選択した状態でプロパティーから編集してもよい。

[[instance02]]
.名前を「game1」に変更する
image::GSW-20210827-114800.png[{three-quarters-width}]

[start=3]
. このオブジェクトを、ゲームを表す「Game」クラスのオブジェクトとするために「Gmae」を追加する。
** 「game1」を選択した状態で、プロパティーから「新規作成」ボタンをクリックする（ <<class_def_dialog00>> ）。
** クラスを定義するダイアログが表示されるので、クラスの名前を「GameScore」にする（ <<class_def_dialog01>> ）。

[[class_def_dialog00]]
.オブジェクトを選択してクラスを追加する
image::GSW-20210827-115726.png[{three-quarters-width}]


[[class_def_dialog01]]
.クラス「GameScore」を定義する
image::class_def_dialog01.png[{half-width}]

[start=4]
. オブジェクトの表示も「game1 : GameScore」のように変わる（ <<instance03>> ）。

[[instance03]]
.クラスを追加した結果「game1」が「game1:GameScore」に変わった
image::instance03.jpg[{quarter-width}]
--

==== フレームのオブジェクトを作成する

ゲームと同じように、フレームについてもインスタンス仕様を追加して、クラス名として「Frame」をつけます。
また、ユースケース記述から、1投目と2投目のピン数、スペアボーナスとストライクボーナスを保持する必要がありそうだとわかっています。
これらは、個別のインスタンス仕様と考えることもできますが、ここでは Frame に従属する情報と考えて属性にしてみます。

.フレームを表すオブジェクトを追加し、「Frame」クラスと属性を定義する
--
. パレットから「インスタンス仕様」を図に追加する。
. フレーム名として「01」、クラス名として「Frame」をつける（ <<instance04>> ）。

[[instance04]]
.フレームオブジェクトと「Frame」クラスを追加する
image::instance04.png[{three-quarters-width}]

[start=2]
. フレームオブジェクトを選択した状態で、プロパティーボタンをクリックする（ <<instance06>> ）。

[[instance06]]
.「Frame」クラスのプロパティーダイアログを開く
image::instance06.png[{three-quarters-width}]

[start=3]
. 「Frame」クラスに従属する情報をクラスの属性に追加する（ <<instance07>> ）。
** 「属性」タブを開く。
** 「＋」ボタンで属性を追加し、名前を入力する。
** 「first」「second」「spare_bonus」「strike_bonus」を定義する。

[[instance07]]
.「Frame」クラスに従属する情報を属性に追加した
image::instance07.png[{half-width}]

[start=4]
. 追加したオブジェクトは <<instance08>> のように変わる。
** 属性は追加されたが、このオブジェクトには属性値はまだ設定されていない。

[[instance08]]
.属性が追加された後の「Frame」クラスのオブジェクト
image::GSW-20210827-124621.png[{quarter-width}]

[start=5]
. 作成したフレームオブジェクトを選択すると、属性のインスタンス（スロットと呼ぶ）を編集するプロパティーが表示される（ <<object_attribute_01>> ）。
** 各属性の「値」の欄をダブルクリックすると、値が設定できるようになる。
. オブジェクトに属性値を設定する。
** 1ストライクなので投目（first）を `10` にする。
** 2投目（second）は投球していないが、ここでは `0` としておく。
** ボーナスは未確定だが、これも `0` としておく。

[[object_attribute_01]]
.オブジェクトの属性値のプロパティーを開く
image::object_attribute_01.png[{three-quarters-width}]
.png[{three-quarters-width}]

[start=7]
.属性値を設定するとオブジェクトにも値が反映される（ <<object_attribute_02>> ）。

[[object_attribute_02]]
.オブジェクトに属性値が設定された
image::object_attribute_02.png[{quarter-width}]

--

もちろん、別の捉え方をしているのであれば、オブジェクトや保持する属性などが異なってきます。
この演習では、 <<object_attribute_02>>  のように捉えて、以降の設計を進めます。


==== ゲームの進行に合わせてオブジェクトを追加する

続いて、進行中のゲームのスコア（ <<classic_score_sample02>> ）を例として、オブジェクト図にインスタンスを追加してみます。


[[classic_score_sample02]]
.第6フレーム投球後のスコアの例
image::classic_score_sample02.jpg[{full-width}]


各フレームの情報を格納するデータ領域は、1ゲーム分を先に用意しておく方法や、ゲームの進行に応じて1フレームずつ増やす方法もあります。
ここでは、1フレームずつ追加する方法を使ってみましょう。
また、前後のフレームとのつながりを保持する方法にも、配列やリストを使う方法があります。ここでは、連結リスト（Linked List）を使ってみることにしましょう。

そして、ゲームからみて「先頭のフレーム」と「現在投球中のフレーム」がわかるよう、「game1」 オブジェクトからは、それぞれ別のリンクを張って、辿れるようにしておきます。

ではまず、ここまでに作成した「GameScore」クラスのオブジェクト「game1」と「Frame」クラスの1フレーム目のオブジェクト「01」の間にリンクを引くところから始めましょう。

.オブジェクトの属性値を設定する
--
. ゲームからフレームへリンク（関連のインスタンス）を引く。
** パレットからリンクを選択し「game1:GameScore」にカーソルを移動して青い枠を出す（ <<object_link_01>> ）。
** マウスをドラッグして「01:Frame」へリンクを伸ばし、青い枠が出たらマウスのボタンを離すとリンクが引ける（ <<object_link_02>> ）。

[[object_link_01]]
.ゲームからフレームへリンクを引く
image::object_link_43.png[{half-width}]

[[object_link_02]]
.ゲームからフレームへリンクを引いた
image::object_link_76.png[{half-width}]

[start=2]
. ゲームはフレームを参照するので、誘導可能の矢印をつける。逆は未確定なので誘導可能性を未確定（矢印をつけない）にしておく。
** リンクのフレーム寄りでマウスの右クリックして、「誘導可能性＞誘導可能」を選択する（ <<object_link_03>> ）。
** リンクに誘導可能を示す矢印が引かれる（ <<object_link_04>> ）。

[[object_link_03]]
.ゲームからフレームへのリンクを誘導可能にする
image::object_link_291.png[{half-width}]

[[object_link_04]]
.ゲームからフレームへのリンクを誘導可能にした
image::object_link_296.png[{quarter-width}]

[start=3]
. ゲームがフレームを参照するときに使うリンク端に名前をつける。ここでは先頭のフレームを指すリンクなので、リンク端名「head」をつける。
** リンクのフレーム寄りでマウスの右クリックして、「リンク端の設定」を選択する（ <<link_end_01>> ）。
** リンク端に、現在つながっているインスタンスの名前「01」割り当てられる。これを「head」に変更する（ <<link_end_02>> ）。

[[link_end_01]]
.フレーム側のリンク端に名前をつける
image::link_end_354.png[{half-width}]

[[link_end_02]]
.フレーム側のリンク端に名前をつけた
image::link_end_378.png[{quarter-width}]

[start=4]
. 同様にして、現在のフレームを指すリンクを追加し、リンク端名「current」をつける（ <<link_end_03>> ）。

[[link_end_03]]
.別のリンク「current」を追加した
image::link_end_400.png[{quarter-width}]
--


第2フレームを追加しましょう。
追加するフレームのピン数は、 <<classic_score_sample02>>  を参照してください。

.第2フレームを追加し、ピン数を設定する
. パレットから「インスタンス仕様」を図に追加する。
. 追加したインスタンス仕様の名前を「02」を入力すると、図に反映される（ <<add_2nd_frame01>> ）。
. ベースクラスのプルダウンメニューから「Frame」を選択する。

[[add_2nd_frame01]]
.インスタンス仕様を追加して名前とクラスを設定した
image::add_2nd_frame01.png[{three-quarters-width}]

[start=3]
. Frameクラスに設定後は、プロパティーにピン数などのスロットが表示される。
. <<classic_score_sample02>>  を参照して、1投目、2投目のピン数を設定する（ <<add_2nd_frame02>> ）

[[add_2nd_frame02]]
.追加したフレームにピン数を設定した
image::add_2nd_frame02.png[{three-quarters-width}]

前後のフレームとのつながりには連結リスト（Linked List）を使ってみることにしました。
連結リストになるよう、追加した第2フレームと第1フレームの間にリンク（関連のインスタンス）を追加しましょう。

.フレームの間にリンクを追加する
. パレットからリンクを選択し、「01:Frame」から「02:Frame」へリンクを引き、誘導可能にする（ <<add_2nd_frame03>> ）。

[[add_2nd_frame03]]
.フレームの間にリンクを追加し、誘導可能にした
image::add_2nd_frame03.png[{half-width}]

[start=2]
. 追加したリンクを選択した状態でプロパティーを編集する（ <<add_2nd_frame04>> ）。
** ターゲットが「02」になっているリンク端のタブを選択する。
** リンク端の名前を「next」とする。

[[add_2nd_frame04]]
.第2フレーム側のリンク端の名前を「next」とした
image::add_2nd_frame04.png[{three-quarters-width}]

[start=3]
. 同様にして、previousを意味するリンク「prev」も追加する（ <<add_2nd_frame05>> ）。

[[add_2nd_frame05]]
.第1フレームへ向かうリンクを追加して、リンク端の名前を「prev」とした
image::add_2nd_frame05.png[{half-width}]

[start=4]
. 第1フレームの「prev」、第2フレームの「next」のつながる先はないので、それぞれについてインスタンス仕様から「nil」を追加しリンクを追加しておく（<<add_2nd_frame06>> ）。

[[add_2nd_frame06]]
.両端に「nil」へのリンクを追加した
image::add_2nd_frame06.png[{three-quarters-width}]


[start=5]
. 現在投球中のフレームを指すリンク「current」は、第2フレームを指すように変更する（ <<add_2nd_frame07>> ）。
** リンクを選択し、誘導可能なリンク端（「current」と書いてある側）をマウスでドラッグする。
** マウスカーソルを第2フレームの枠内へ移動してドロップすると、接続先を変更できる。

[[add_2nd_frame07]]
.「current」が第2フレームを指すように変更した
image::add_2nd_frame07.png[{three-quarters-width}]

[start=6]
. 第1フレームはストライクだったので、第2フレームの2投分によってストライクボーナスを計算してスロットの値に反映する（ <<add_2nd_frame08>> ）。
** スペアボーナスとストライクボーナスに設定する値は、ユースケース記述「 <<use_case_desc08>> 」に記述した方法を使って求める。

[[add_2nd_frame08]]
.第1フレームのストライクボーナスを計算して、スロット値を更新した
image::add_2nd_frame08.png[{three-quarters-width}]


これで、第2フレームまで投球した場合のオブジェクト図ができました。
同じようにして、 <<classic_score_sample02>> を参照しながら、第6フレーム投球後のオブジェクト図を作成してみましょう（ <<score_sample02>> ）。

[[score_sample02]]
.第6フレーム投球後のオブジェクト図
image::score_sample02.png[{full-width}]

オブジェクト図を作成してみることで、スコアを記録するために必要なクラスや、クラスが持つ属性などを検討できましたね。

また、ストライクやスペアのボーナスには「次のフレーム」あるいは「次の次フレーム」のピン数が影響します。
ユースケースに従ってオブジェクト図にオブジェクトを追加することで、現在のフレームの1投目あるいは2投目にピン数を入力されたときが、「前のフレーム」や「前の前のフレーム」のボーナスを計算するタイミングということもわかってきました。


[NOTE]
--
構成要素のどの部分をインスタンス仕様とし、どの部分をインスタンス仕様の属性として扱うかによって、作成されるオブジェクト図は変わってきます。
<<score_sample02>> は、何通りも作成しうるオブジェクト図の作成例の1つです。

より実務的な検討においては、複数の捉え方を考えた上でその考えに基くオブジェクト図を作成し、それらの中からより妥当と考えられるものを選ぶべきでしょう。
--

=== ゲームスコアのクラス図を描く

オブジェクト図が作成できたので、これを元にクラス図を作成してみましょう。

==== 設計モデルにクラス図を追加する

まず、「ゲームスコアのクラス図」を追加しましょう。


.ゲームスコアのクラス図を追加する
--
. モデルにクラス図を追加する（ <<class00>> ）。

[[class00]]
.モデルにクラス図を追加する
image::class00.png[{half-width}]

[start=2]
. 追加した図を「ゲームスコアのクラス図」とする（ <<class01>> ）。

[[class01]]
.追加した図を「ゲームスコアのクラス図」とした
image::class01.png[{half-width}]
--

==== ゲームのクラスを追加する

「構造ツリー」をみると、オブジェクト図を作成したとき登録した「 GameScore 」クラスや「 Frame 」クラスが見つかります。
これらを1つずつドラッグ＆ドロップして、クラス図に追加します（ <<class02>> ）。

[[class02]]
.GameScore クラスと Frameクラスをクラス図に追加する
image::class02.png[{three-quarters-width}]


==== クラス間の関連を追加する（１）

前に作成したオブジェクト図（  <<score_sample02>>  ）を参照して、記載されているリンクを関連として追加します。
まず、「 GameScore 」クラスから「 Frame 」クラスへ向かって連を引きましょう。

.クラス間の関連を追加する
. パレットから、矢印付きの関連を選択し、「 GameScore 」クラスから「 Frame 」クラスへ向かって関連を引く（ <<class03>> ）。

[[class03]]
.先頭フレームを指す関連「head」を引いた
image::class03.png[{half-width}]

[start=2]
. 関連を選択した状態で、プロパティーからターゲットが Frame の関連端のタブを開き、名前を「head」とする（ <<class04>> ）。

[[class04]]
.関連端名を「head」とした
image::class04.png[{three-quarters-width}]

[start=3]
. 「 GameScore 」クラスからみた「Frame」クラスへの多重度を設定する。
** まだ1投もしていないときはフレームがなく、1投して以降はフレームが複数ある。すなわち、先頭のフレームを指すリンク（関連のインスタンス）は、「つながっていない」か「1つある」かのいずれかになる。
** この事情に見合うよう、 関連を選択した状態で、プロパティーからターゲットが Frame の関連端のタブを開き、「多重度」を「 `0..1` 」に設定する（ <<class05>> ）。
. 

[[class05]]
.関連の多重度を「 `0..1` 」に設定した
image::class05.png[{three-quarters-width}]

[start=4]
. 「head」と同様、「current」についても関連を引く（ <<class06>> ）。
** パレットから、矢印付きの関連を選択し、「 GameScore 」クラスから「 Frame 」クラスへ向かって関連を引き、関連端名をつける。
** 「 GameScore 」クラスからみると、まだ1投もしていないときはフレームがなく、1投して以降はフレームが複数ある。つまり、現在のフレームを指す関連のインスタンス（リンク）は、「ない」か「1つある」かのいずれかになる。この事情に見合うよう、関連の多重度を設定する。

[[class06]]
.現在のフレームを指す関連「current」を引き、関連端名と多重度を設定した
image::class06.png[{quarter-width}]


==== クラス間の関連を追加する（２）

次に、フレーム同士の間に引かれていた「next」「prev」というリンクを関連として引きましょう。
もとのリンクは「 Frame 」クラスのインスタンスから、同じ「 Frame 」クラスのインスタンスへと引かれていました。
このようなリンクを関連に反映するときは、自クラスへつながる関連（自分から自分へ向かう関連）として表します。
また、先頭と末尾のフレームは、「nil」とつながっていました。
このようなリンクを反映するときは、つながっていない関連があるとみなします。つながっていない場合があるときは、関連の多重度に「 `0` 」の場合を含めます。結果として、この部分の多重度は「 `0..1` 」となります。

.フレームからフレームへの関連を引く
. 「Frame 」クラスから「 Frame 」クラスへ向かって関連を引く。
** パレットから矢印付きの関連を選択する。
** 「Frame 」クラス上でマウスをクリックして、一度カーソルをクラスから外へ出してクリックし、再び「Frame 」クラス上にカーソルを戻してクリックする（ <<class08>> ）。
** 自分自身へ向かう関連が引けるので、関連の線を整える（ <<class10>> ）。

[[class08]]
.マウスをクラスの上でクリックし、クラスの外でクリックし、再びクラスの上でクリックする
image::class08.png[{quarter-width}]

[[class10]]
.自分自身へ向かう関連が引けたら、関連の線を調整する
image::class10.png[{quarter-width}]

[start=2]
. 関連端名と多重度を設定する
** 関連端名に「prev」、多重度に「 `0..1` 」設定する（ <<class11>> ）。

[[class11]]
.関連端名と多重度を設定した
image::class11.png[{half-width}]


[start=3]
. 「next」についても関連端名と多重度を設定する（ <<class12>>）。
** 自分自身へ向かう関連を追加する。
** 関連端名を「next」、多重度を「 `0..1` 」とした。


[[class12]]
.「next」についての関連を追加した
image::class12.png[{half-width}]


[TIP]
--
関連「next」と「prev」は、ひとつの双方向の関連として描くこともできます。このときは、ひとつの双方向関連の両端の関連端名を「next」と「prev」とします（ <<class13>> ）。

[[class13]]
.関連「next」と「prev」をひとつの双方向関連で表した場合
image::class13.png[{quarter-width}]


--

==== クラスに操作を追加する

「GameScore」クラスは、ゲームの進行とともに「Frame」クラスのオブジェクトを作成し、スコアを記録していきます。
このとき、外部からゲームの進行に応じてピン数を受け取る必要がありますね。
そこで、ゲームを進めつつ、ピン数を「GameScore」クラスへ渡す「Game」クラスを追加しましょう（ <<class14>> ）。

[[class14]]
.Gameクラスを追加した
image::class14.png[{quarter-width}]

また、「Game」クラスには、スコアラーの入力を受けつけてゲームを進めるための働きが必要になります。
クラスにそのような働きを持たせるときは「操作」を用意します。

ここは、ゲームを進める操作ということで名前を「play」としておきましょう。
操作の内容は、振舞いのモデルで検討しましょう。
ここでは操作が必要ということまで決めておけばよいでしょう。


.「Game」クラスに操作「play」を追加する（ <<class15>> ）
. 「Game」クラスを選択した状態で、プロパティーから「操作」タブを選択する。
. 左下の「＋」アイコンをクリックして、操作のエントリを追加する。
. 操作の名前を編集して「play」にする。
. クラスの表示も操作「play」が追加される。

[[class15]]
.Gameクラスに操作「play」を追加した
image::class15.png[{three-quarters-width}]

また、「GameScore」クラスにも、ゲームの進行とともにピン数を受け取ってスコアを記録する働きが必要になりますね。
そこで、「scoring」という操作を用意します（ <<class16>> ）。
この操作の処理内容も、振舞いのモデルで検討しましょう。
「Game」クラスから関連を引きます。関連端名は「game_score」としました。ゲームがあればスコアは必ず用意するので、多重度は「 `1` 」に設定しています。

[[class16]]
.GameScoreクラスに操作「scoring」を追加した
image::class16.png[{three-quarters-width}]


これでクラス図の最初の版はできました。
まだ振舞いを検討していませんので、追加した操作は吟味できていません。
振舞いを検討するときに、これらの操作についても検討しましょう。


[[_behavier_design]]
== スコア記録の振る舞いを図にする

[.lead]
スコアの構造を検討できたので、こんどは、ゲームを進めるときの動作をモデル図を使って整理してみましょう。

=== 振る舞いの図を選択する

振る舞いを表す図には「 <<behaiver_diagrams>> 」に挙げたようなものがあります。

[[behaiver_diagrams]]
.よく使う振舞いのモデル図
[options="header", cols="10,40"]
|===
| 図の種類 | 説明
| シーケンス図 | クラスやオブジェクトの間のやり取りを整理するのに向いています。

| アクティビティ図 | 処理の流れや条件による処理の分岐を表すのに向いています。

| ステートマシン図 |  起きるのを待っているできごと（イベント）と、イベントが起きた時の処理（アクション）を使って振る舞いを表すのに向いています。
|===

では、ゲームを進めるときの動作を考えるとき、どの図を使うのがよいでしょうか。
たとえば、「Game」クラスと「GameScore」クラスは「 <<game_gamesocre_interaction>> 」に示すような手順となります。

[[game_gamesocre_interaction]]
.GameクラスとGameScoreクラスの間のやり取り
. システムの利用者は「Game」クラスの操作「play」を呼び出す。
. 実際のゲームが進行する間、「Game」クラスは次のことを繰り返す。
.. 「Game」クラスは、ゲームで投球がある都度、ピン数の入力を受け付ける。
.. 「Game」クラスは、「GameScore」クラスの操作「scoring」を呼び出して、入力されたピン数を渡す。
.. 「GameScore」クラスは、操作「scoring」を実行してスコアを記録する。

このやり取りを図で表したいなら、シーケンス図が向いているでしょう。
ですが、この程度であるなら、必ずしも図を描いて処理の内容を検討するほどではないでしょう。

一方で、「GameScore」クラスの操作「scoring」の動作では、ゲームが進むたびにフレームのインスタンスの追加やボーナスの計算が必要です。
また、ボーナスを計算するには、いまどのような状況か（何フレーム目の何投目か）を判断する必要もあります。
ということは、操作「scoring」の動作では、ゲームの状況を判断するために「状態を維持する」必要がありそうです。
そして、ピン数を受け取ったときにスコアを計算するというのは、「できごとが起きたときに何かをする」という考え方で動作を整理する必要があることを意味しています。
この考え方に従って振る舞いを検討するには「ステートマシン図」を使うのがよさそうです。


=== ステートマシン図を描く

では、「GameScore」クラスの操作「scoring」の動作を検討するために、ステートマシン図を作成しましょう。

振る舞いの捉え方によって、振る舞いの図がどのようなものになるのかはかわります。
この演習では「ピンの入力を待っていてピン数が入力されたらスコアを計算する」という考え方に従って振る舞いを考えてみましょう。

==== 設計モデルにステートマシン図を追加する

まず、「ゲームスコアのステートマシン図」を追加しましょう。
追加したいのは「GameScore」クラスの振舞いを表すステートマシン図なので、それがわかるよう「GameScore」クラスに対して追加しましょう。

.ゲームスコアのステートマシン図を追加する
--
. 「GameScore」クラスにステートマシン図を追加する（ <<stm00>> ）。

[[stm00]]
.「GameScore」クラスにステートマシン図を追加する
image::stm00.png[{half-width}]

[start=2]
. 追加した図を「GmaeScoreのscoringのステートマシン図」とする（ <<stm01>> ）。

[[stm01]]
.追加した図を「GameScoreのscoringのステートマシン図」とした
image::stm01.png[{three-quarters-width}]
--


==== 状態と状態遷移を追加する


[IMPORTANT]
.状態名は後まわしにする
--
状態を配置すると、状態名をつけたくなります。ですが、状態名をつけるのは後まわしにしましょう。
なぜなら、どのような状態なのかを決定する要因は、状態名ではなく、イベントやアクションだからです。
そして、イベントやアクションが定まったら、イベントやアクション（あるいはそれらの元となる仕様上の処理の名前など）を元に状態名を命名します。
--

ステートマシン図を使って振る舞いを考える時、最初に考えるのは「何が起きるのを待っているのか」です。
ユースケース記述「 <<use_case_desc08>> を読むと、ゲームを始めた段階では、「1投目のピン数を受け取るのを待っている」と考えればよさそうです。

まず、ステートマシン図に状態と状態遷移を追加しましょう。

.イベント「ピン数を受け取った」を追加する
. ステートマシン図に状態を2つ追加する。
** パレットから「状態」のシンボルを選択して、図に配置する（ <<stm02>> ）。
** 一方の状態には、最初の状態だとわかるよう「開始疑似状態」をつける。

[[stm02]]
.状態と開始疑似状態を追加した
image::stm02.png[{half-width}]

[start=2]
. 状態遷移を追加する。
** パレットから「遷移」のシンボルを選択して、一方の状態にマウスカーソルを移動する。
** 青い枠が現れたら、マウスをクリックし、そのままドラッグする（ <<stm03>> ）。
** 折り曲げたいときは途中でもマウスをクリックする。
** もう一方の状態の中にマウスを移動して青い枠が現れたらマウスを離すと、「遷移」が引かれる（ <<stm04>> ）。


[[stm03]]
.状態と状態の間に遷移を追加する
image::stm03.png[{half-width}]


[[stm04]]
.状態と状態の間に遷移を追加した
image::stm04.png[{half-width}]


==== イベントを追加する

状態遷移が追加できたら、最初の状態で起きるのを待っているできごとを考えて、イベントとして追加しましょう。

最初の状態では、投球したピン数を受け取るのを待っていますね。
そして、状態が遷移するときは、既に（いままさに）受け取ったときになります。
そこで、イベントとして表すときには「ピン数を受け取った」のように表します。
「受け取る」とすると、まだ受け取るのを待っているところなのか、もう受け取った後なのかはっきりしません。
あるいは、「渡す（渡した）」としてしまうと「GameScore」クラスがピン数を渡すとみなされてしまいます。
イベント名を考えるときは、動作の主体やイベントが「起きた」といった時制を意識してみてください。

.イベント「ピン数を受け取った」を追加する
. 追加した遷移を選択した状態で、プロパティーの「トリガー」を編集して「ピン数を受け取った」とする（ <<stm05>> ）。
. 受け取るピン数がわかるよう、ピン数をパラメーターとして追加しておいた。

[[stm05]]
.イベント「1投目のピン数を受け取った」を追加した
image::stm05.png[{three-quarters-width}]

==== アクションを追加する

次に考えるのは、イベントが起きたときに実行したい処理（アクション）です。
1投目のピン数を受け取るのを待っているときにやりたい処理は、ユースケース記述「 <<use_case_desc08>> 」の「現在の状態が、1投目のピン数入力待ちのとき」に書いてある処理です。
アクションに記載する処理と次の状態への遷移がわかるよう、抜粋した記述に説明を追加しておきました（ <<use_case_desc08_sub01>> ）。

[[use_case_desc08_sub01]]
.「現在の状態が、1投目のピン数入力待ちのとき」の処理（ユースケース記述より抜粋）
--
. ゲームスコアに新しいフレームを追加する。（アクションでやりたいこと）
. 現在のフレームの1投目にピン数を記録する。（アクションでやりたいこと）
. 1投目がストライクだったときは、現在の状態を次の1投目のピン数入力待ちに変更する。（次の状態への遷移1）
. ストライクでなかったときは、現在の状態を2投目のピン数入力待ちに変更する。（次の状態への遷移2）
--

ステートマシン図にアクションを書くときは、このユースケース記述をそのまま書くのではなく、まず「操作に追加してそれをアクションとして呼び出す」方法を原則としましょう。

[NOTE]
.アクションを操作にしてから書く理由
--
. その処理に名前をつけることです。名前をつけることで、まとまりのある処理と捉えやすくなります。
. 再利用の促進です。操作にしておけば、他の場面でも呼び出して使えます。
--

この演習において、同じ処理が他の状態に現れる場面があるのかはっきりしていませんが、原則に従って作成してみます。

操作の名前は、「1投目のピン数入力待ちのとき」のアクションという意味を込めて「first_action」としましょう。

.「1投目のピン数入力待ちのとき」のアクションを追加する
. 「Frame」クラスに、操作「first_action」を追加する（ <<class20>> ）。
** クラス図を開き、 Frame クラスに操作を追加する（操作を追加する手順は省略）。


[[class20]]
.Frameクラスに操作「first_action」を追加した
image::class20.png[{half-width}]

[start=2]
. 追加した操作をアクションに追加する（ <<stm06>> ）。
** アクションを追加したい状態を選択して、プロパティーの「入場/実行/退場」タブを選択する。
** 「入場動作」に「first_action」と入力する。
** マウスカーソルを図に戻すと、入力が反映される。
** ノートを追加して、アクション詳細を書いておいた。

[[stm06]]
.アクション「first_action」を状態に追加した
image::stm06.png[{full-width}]

そして、「 <<use_case_desc08_sub01>> 」の後半部分、次の状態への遷移を追加します。
記述をみると状態遷移は2つあります。
まず、考えやすいストライクでなかったときを考えていましょう。
このときは、2投目のピン数を受け取るのを待つことになりますので、そのための状態遷移とイベントを追加します。

.2投目のピン数入力待ちに遷移する状態遷移を追加する（ <<stm07>> ）。
. 新しい状態を追加する。
. 追加した状態へ向かう状態遷移を追加する。

[[stm07]]
.2投目のピン数入力待ちに遷移する状態遷移を追加した
image::stm07.png[{three-quarters-width]

==== ストライクのときの状態遷移を追加する

では、ストライクだったときはどうしたらよいでしょうか。
このときは、「1投目のピン数入力待ちのとき」のアクションを実行した上で、次のフレームの1投目のピン数を受け取るのを待つことになります。
つまり、前の状態に戻るということです。
この状態遷移を追加してみましょう。

.ストライクだったときの状態遷移を追加する（ <<stm07-2>> ）。
. 最初の状態への状態遷移を新しい状態を追加する。
. 追加した状態へ向かう状態遷移を追加する。

[[stm07-2]]
.次の1投目のピン数入力待ちに遷移する状態遷移を追加した（期待通りに動作しない）
image::stm07-2.png[{full-width]]

この状態遷移には、待っているイベントがありません。
イベントが書いていない遷移は、遷移元の状態におけるアクションが実行された後、イベントが発生していなくても状態が遷移するという意味になります。
このような状態遷移を「自動遷移（ラムダ遷移）」といいます。

しかし、この自動遷移があると、2投目のピン数を受け取るのを待っているにもかかわらず、すぐこちらの状態遷移で遷移してしまいますね。
これは期待している動作ではありません。
つまり、ストライクのときとそうでないときは、状態処理は同じですが区別する必要がありそうです。
区別するということは、2投目を待つ場合と、ストライクで次のフレームを進む場合は別の状態と考えるわけです。


同じイベントを受け取ったときに、条件によって遷移先を変えたい場合は、イベントにガード条件を追加します。
ここでは、「ストライク」の場合と「ストライクでない」場合です。

.ストライクかどうかで状態遷移を区別する
. ストライクのきの状態を追加する（ <<stm08>> ）。
** 新しい状態を追加する。
** 最初の状態から追加した状態へ状態遷移を引く。
** 追加した状態から最初の状態へ状態遷移を引く。


[[stm08]]
.ストライクのときのために状態を追加した
image::stm08.png[{full-width]]




==== イベントとアクションの追加を繰り返す

引き続き、ユースケース記述「 <<use_case_desc08>> 」を参照して、イベントとアクションを追加します。

1投目のピン数を受け取った状態では、起きるのを待っているできごとは「2投目のピン数を受け取る」ことです。
イベントとしては「2投目のピン数を受け取った」になります。

ふたたび、操作と状態と状態遷移を追加して、このイベントを追加します。
追加する操作は、「roll_second」としましょう。

.アクション「2投目のスコアを計算する」を追加する
. 「Frame」クラスに、操作「roll_second」を追加する（ <<class21->> ）。

[[class21-]]
.Frameクラスに操作「roll_second」を追加した
image::class21.png[{half-width}]

[start=2]
. イベントとアクションを追加する（ <<stm07>> ）。
** 状態と状態遷移を追加する。
** 状態遷移に、イベント「2投目のピン数を受け取った」を追加する。
** 状態に、アクション「2投目のスコアを計算する」を追加する。
** ノートを追加して「Frameクラスの roll_second を使う」と書いておく。

[[stm07---]]
.アクション「2投目のスコアを計算する」を追加した
image::stm07.png[{three-quarters-width}]

そして、もし、ストライクやスペアの処理を勘案しないのであれば、この後は最初の状態に戻ればよいですね。
その場合、ステートマシン図は「 <<stm08-->> 」のようになるでしょう。

[[stm08--]]
.最初の状態に戻る自動遷移を追加した
image::stm08.png[{three-quarters-width}]


この状態遷移にはイベントがありません。このような状態遷移を「自動遷移（ラムダ遷移）」といいます。
自動遷移の場合、前の状態のアクションが実行された後、イベントが発生していなくても状態が遷移します。

これで、毎フレーム必ず2投するのを延々繰り返すように動作するステートマシン図ができました。


==== ストライクの処理を追加する

「1投目のピン数を受け取った」後の処理の詳細は、ユースケース記述「 <<use_case_desc08>> 」の「1投目のスコアを計算する」に書いてあります。これを「 <<act01>> 」に抜粋しておきます。

[[act01]]
.1投目のスコアを計算する処理の詳細
. ゲームスコアに新しいフレームを追加する。
. 現在のフレームの1投目にピン数を記録する。
. 1投目がストライクだったときは、現在の状態を次の1投目のピン数入力待ちに変更する。
. ストライクでなかったときは、現在の状態を2投目のピン数入力待ちに変更する。


「 <<stm08>> 」には、1投目で10ピン倒してストライクになったときの処理が反映できていません。
反映するには、ステートマシン図をどのように修正すればよいでしょうか。

まず、1投目のピン数を受け取ったら1投目のスコアを計算するのは変わりありません。
そして、受け取ったピン数が10ピンであったときは、2投目のピン数を受け取るのを待たずに次のフレームへ進みます。
そのために、たとえば「 <<stm09>> 」のような状態遷移を追加してみたらどうでしょうか。

[[stm09]]
.ストライクのときの状態遷移の検討（1）（期待通りに動作しない）
image::stm09.png[{three-quarters-width}]

一見、これでなんとかなりそうに思えます。
ところが、ここに自動遷移を書いてしまうと、1投目のスコアを計算した後は必ずこの自動遷移へ向かいます。
ここでは、2投目のピン数を受け取るのも待たなくてはなりませんが、いつもそれよりも先に自動遷移してしまうでしょう。
つまり、ここに自動遷移を書いてしまうと、2投目のピン数を受け取るイベントが来るのを待たなくなってしまうのです。

それでは、ストライクで次のフレームへ進むために、別の状態を追加してみます（ <<stm10>> ）。

[[stm10]]
.ストライクのときの状態遷移の検討（2）（あいまいさが生じる）
image::stm10.png[{three-quarters-width}]

これで、「2投目のピン数を受け取るのを待つ」ところには影響がなくなりました。
自動遷移によって次のフレームの1投目を待つところへ戻るのも問題ないでしょう。
しかし、この図では「1投目のピン数を受け取った」という同じイベントで、2つの遷移先ができてしまっています。
このように、同じイベントを待つ2つの状態遷移があると、どちらへ遷移するのかあいまいになってしまいます。
このままでは、どのように動作するのか決められません。


この問題を避けるには、1投目のピン数を受け取ったときに、それがストライクなのか調べて区別すればよいでしょう。
そこで、イベントにはイベントが起きたときに評価する条件を追加できるようになっています。
この条件のことを「ガード条件」と呼びます。

[IMPORTANT]
--
ガード条件は、イベントを待っているときではなく、イベントが起きたときに評価されることを注意してください。
--

まず、ストライクか調べて真偽を返す操作を追加しましょう。
追加する操作の名前は「strike?」としましょう。

[TIP]
--
Rubyでは、真偽を返す操作（Rubyではメソッドと呼びます）の末尾に「?」をつける習慣があります。
--

.ストライクのときの状態と状態遷移を追加する
. 「Frame」クラスに、操作「strike?」を追加する（ <<class22>> ）。
** 「strike?」を選択した状態で、プロパティーのベースタブの「返り値」のプルダウンメニューから「boolean」を選択する。

[[class22]]
.Frameクラスに操作「strike?」を追加した
image::class22.png[{full-width}]

[start=2]
. イベントにガード条件を追加する（ <<stm11>> ）。
** イベント「1投目のピン数を受け取った」を選択した状態で、プロパティーの「ガード」欄に「ストライクではなかった」と書く。
** マウスカーソルを図に戻すと、図上のイベントにガード条件が追加される。
** 状態遷移にノートを追加して「Frameクラスの strike? を使う」と書いておく。
** 前からあった状態遷移の方イベントは「1投目のピン数を受け取った[ストライクではない]」に変更する。
** 追加した状態のアクションに「1投目のスコアを計算する」を追加する。

[[stm11]]
.イベントにガード条件を追加した
image::stm11.png[{full-width}]


[start=3]
. ストライクのときの状態を状態遷移を追加する（ <<stm12>> ）。
** （まだ追加していなかった場合）ストライクのときのための状態と状態遷移を追加する。
** 追加した状態遷移に、イベント「1投目のピン数を受け取った[ストライク]」を追加する。
** 追加した状態のアクションに「1投目のスコアを計算する」を追加する。

[[stm12]]
.ガード条件を使ってストライクのときの状態と状態遷移を追加した
image::stm12.png[{three-quarters-width}]

これで、同じイベントが起きても、ガード条件の評価結果が異なれば別の状態へ遷移できるようになりました。

==== サービスフレームの処理を追加する

最終の第10フレームは、3投目を投球できます（サービスフレームと呼ぶこともあるそうです）。
この処理に対応するにはどうしたらよいでしょうか。

まず、最終フレームの3投目のピン数を保持するために、3投できるような Frameクラスを用意しましょう。
これは、 Frame クラスを継承すれば作成できそうです（ <<class08_svg>> ）。

そして、最終フレームを追加するのは、通常のフレームと同じように操作 add_frame に任せましょう。
その代わり、現在のフレームが何フレーム目なのかわかるよう、GameScoreクラスに作成しているフレームの数を覚えておく属性「size」を追加します。

[[class08_svg]]
.「ServiceFrame」クラスを追加し、GameScoreクラスに属性「size」を追加した
image::class08.svg[{half-width}]

==== スペアの判定を追加する

1投目が10ピンでない場合で、2投目で残りのピンをすべて倒した場合は「スペア」になります。
Frameクラスに、スペアかどうか判定する操作「 spare? 」を追加しておきましょう（ <<class09_svg>> ）。


[[class09_svg]]
.Frameクラスに操作「spare?」を追加する
image::class09.svg[{half-width}]


==== 状態名をつける

<<stm06_svg>> について、イベントとアクションが決まったので、これらを元に状態名をつけます。
状態名をつけるときは「 <<state_naming_rules> 」のような原則を使ってつけます。

[[state_naming_rules]]
.状態名をつけるときの原則
. 待っているイベントやそのイベントを期待する状況を使って「〜待ち」とする
. 実行中のアクティビティやそのアクティビティが関連する状況を使って「〜中」とする
. 最後の状態は「〜待ち」や「〜中」とはつけず、「終了」完了」「到着」などとする

状態名は、待っているイベントのうち最も期待しているイベント元に「〜待ち」とつけます。
ところが、イベント名そのものを使うと、複数の状態が同じイベントを待っていると状態名が重複してしまいます。
そこで、仕様やユースケース記述を参照して、そのイベントが起きるときの状況を表わしている名前を探して状態名にします。
たとえば「ピン数受け取り待ち」などとなるでしょう。

もし、イベントの発生を待っている間、継続して実行している処理があれば、おそらく「do アクティビティ」の処理として書いてあるでしょう。
この処理を元に「〜中」とつける方法もあります。
この場合も、アクションそのものではなく、仕様やユースケース記述からそのアクションを実行している状況を示している名前を参照してつけます。
たとえば「2投目投球中」などとなるでしょう。

[WARNING]
--
状態名に「待機中」を使う場合は、要注意です。
対象業務の業務用語として「待機中」が定義されている場合は、そのときを表す名前として使うこともできるでしょう。
これは、業務の用語であるなら、その「待機」が何を待っているのかについても業務として明らかなことが多いからです。
ですが、それ以外の場合は、再考してみた方がよいでしょう。
たいていの場合、待っているということそのものよりも「待っているイベント（や、そのイベントを期待する業務上の状況）は何か」の方が重要です。
--

それでは、状態名をつけてみましょう。
1投目については、同じイベントに対する別の状態遷移と状態を追加します（ <<stm08_svg>> ）。

[[stm08_svg]]
.状態名をつけた
image::stm08.svg[{full-width}]

