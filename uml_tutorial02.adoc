ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_requirement_anaylysis]]
== スコアのデータ構造を調べる

[.lead]
ボウリングスコアはどのような構造になっているでしょうか。
また、スコアをつける手順に従うとき、スコアにはどのような状態があるのでしょうか。


[NOTE]
--
このチュートリアルでは、クラッシックスコアリング <<classic_scoring>> の場合について考えることにします。
--


=== スコアシートの構造をオブジェクト図で表す

スコアシートの例を参照しながら、スコアシートの構造を検討しましょう。

==== スコアシートの例


ゲーム中のスコアシートの例を <<scoresheet01>> に示します。
この例では、1ゲームを2人でプレイしていて、1人目の6フレーム目の第1投目までゲームが進んでいます。
彼らは1フレームずつ交代で投球していることがわかります。
また、彼らがもう1ゲーム分プレイする場合には、このスコアの下にもう一度2人のスコアが追加されるでしょう。

[[scoresheet01]]
.スコアシートの例
image::220128-0001_2.png[{full-width}]

スコアシートを観察してわかることを「 <<scoresheet02>> 」にまとめました。

[[scoresheet02]]
.スコアシートを観察してわかること
* プレーヤー名とその人の10フレーム分の投球が記録の単位になっている（これをゲームと呼ぶことにする）。
* シートには複数のゲームが記録されている。
* シート上には、複数のプレーヤーのゲームが記録されている。
* （おそらく）各人が複数回ゲームを実施する。
* （おそらく）ひとつのゲームの進行中は、複数名で順番に投球して進行する（適当な呼称がないのでゲームセットと呼ぶ）。


「 <<scoresheet02>> 」にまとめたことを元に、スコアシートの構成要素と構成要素同士の関係をモデル図で表してみましょう。

==== プロジェクトに設計モデルを追加する

まず、プロジェクトに設計モデルを追加しましょう。

[TIP]
--
ここでいう設計とは、対象とする業務やサービスに必要となる構成要素を洗い出すことと、それらを使った振舞いを検討することだと考えておけばよいでしょう。
--

[[add_design_model]]
.プロジェクトに設計モデルを追加する
. プロジェクトにモデルを追加する。
** 構造ツリー上で、プロジェクトを選択する。
** 右クリックしてポップアップメニューを開き、「モデルの追加＞モデル」を選択する（ <<add_design_model01>> ）。

[[add_design_model01]]
.プロジェクトにモデルを追加した
image::GSW-20220127-235554.png[{half-width}]


[start=2]
. 追加したモデルに名前をつける。
** 構造ツリー上で、追加したモデルを選択した状態で、プロパティの「ベース」タブを選択する。
** 「名前」を編集して「設計モデル」とする（ <<add_design_model02>> ）。

[[add_design_model02]]
.モデルに設計用のモデルとして名前をつけた
image::GSW-20220127-235739.png[{half-width}]


==== 設計モデルにオブジェクト図を追加する

ゲームスコアのオブジェクトが作られていく様子は、「オブジェクト図（インスタンス図と呼ぶこともあります）」を使って表してみましょう。
{astah} で「オブジェクト図」を作成するときは「クラス図」を使います。
設計モデルにクラス図を追加します。

.ゲームスコアのオブジェクト図を追加する
--
. モデルにクラス図を追加する（ <<object00>> ）。

[[object00]]
.モデルにクラス図を追加する
image::GSW-20220128-001441.png[{half-width}]

[start=2]
. 追加した図を「ゲームスコアのオブジェクト図」とする（  <<object01>> ）。

[[object01]]
.「ゲームスコアのオブジェクト図」を追加する
image::GSW-20220128-001723.png[{half-width}]
--

==== オブジェクト図にスコアシートを追加する

<<scoresheet01>> や「 <<scoresheet02>> 」を参照しながら、スコアシートの具体的な要素をオブジェクト図に追加してみましょう。

まず、「スコアシート」オブジェクトを追加します。

[[add_scoresheet01]]
.スコアシートを表すオブジェクトを追加する
. パレットから「インスタンス仕様」を選択して、図に配置する（ <<add_innstance01>> ）。

[[add_instance01]]
.インスタンス仕様を追加する
image::GSW-20220128-021835.png[{half-width}]

[start=2]
. 名前が「インスタンス仕様0」（数字は作るたびに変わる）となっている。これを、具体的なスコアシートを表す名前に変える。ここでは「scoresheet01」とする（ <<obj_scoresheet01>> ）。
** この名前は、あるスコアシートを指すためのオブジェクト図上での識別子。
** 名前を変更するには、文字列を直接クリックして編集してもよいし、オブジェクトを選択した状態でプロパティから編集してもよい。

[[obj_scoresheet01]]
.名前を「scoresheet01」に変更する
--
image::GSW-20220128-023458.png[{half-width}]

[start=3]
. このオブジェクトを、スコアシートを表す「ScoreSheet」クラスのオブジェクトとするためにクラス「ScoreSheet」を追加する。
** オブジェクト「scoresheet01」を選択した状態で、プロパティから「新規作成」ボタンを
クリックする（ <<class_def_dialog00>> ）。
** クラスを定義するダイアログが表示されるので、クラスの名前を「ScoreSheet」にして「閉じる」をクリックする（ <<class_def_dialog01>> ）。

[[class_def_dialog00]]
.オブジェクトを選択してクラスを追加する
image::GSW-20220128-040656.png[{half-width}]


[[class_def_dialog01]]
.クラス「ScoreSheet」を定義する
image::GSW-20220128-041151.png[{half-width}]

[start=4]
. オブジェクトの表示も「scoresheet01 : ScoreSheet」に変わる（ <<instance03>> ）。

[[instance03]]
.クラスを追加した結果「scoreseet01」が「scoresheet01:ScoreSheet」に変わった
image::GSW-20220128-041457.png[{quarter-width}]
--


==== オブジェクト図にゲームを追加する

次に、「スコアシート」を追加したのと同じ手順で「ゲーム」オブジェクトを追加します。
オブジェクト名を「game01」、クラス名を「Game」としましょう。
また、ゲームを複数回プレイすることを考えて、ゲームの番号を保持するようにしてみましょう。

[[add_game00]]
.ゲームを表すオブジェクトを追加する
. パレットから「インスタンス仕様」を選択して図に配置して「game01」とし、クラスを「Game」とする（ <<add_game01>> ）。

[[add_game01]]
.ゲームを表すオブジェクト「game01」とクラス「Game」を追加する。
image::GSW-20220128-051333.png[{quarter-width}]

[start=2]
. 「Game」クラスの属性に「number」を追加する（ <<add_attr01>> ）。
* 「属性」タブを開く。
* 「＋」ボタンで属性を追加し、属性名に「number」とする。

[[add_attr01]]
.ゲームを表すオブジェクトを追加する
image::GSW-20220128-044458.png[{half-width}]

[start=3]
. 属性を追加したオブジェクト「game01」は <<add_attr02>> のように変わる。
* 属性は追加されているが、オブジェクト固有の属性値はまだ設定されていない。

[[add_attr02]]
.属性を追加した後のオブジェクト「game01」
image::GSW-20220128-045336.png[{quarter-width}]

[start=4]
. オブジェクト「game01」を選択すると、プロパティはオブジェクト「game01」の属性値（スロットと呼ぶ）を編集する表示に変わる。
.  <<scoresheet01>> の場合、1ゲーム目なので、属性値にゲームの番号「1」を設定する（ <<add_attr03>> ）。
* プロパティを編集すると、オブジェクトの表示も更新される（ <<add_attr04>> ）。


[[add_attr03]]
.プロパティから属性値を設定する
image::GSW-20220128-050331.png[{half-width}]


[[add_attr04]]
.属性値が設定されたオブジェクト「game01」
image::GSW-20220128-050303.png[{quarter-width}]


==== オブジェクト図にプレーヤーを追加する

ゲームを追加したのと同じ手順で、プレーヤーを追加しましょう。
<<scoresheet01>> の場合、プレーヤーとして「くぼあき」さんと「うえはら」さんがいますので、オブジェクトは2つ追加します。
属性値にはそれぞれのプレーヤーの名前を設定します。

[[add_player00]]
.プレーヤー 「くぼあき」を表すオブジェクトを追加する
. パレットから「インスタンス仕様」を選択して図に配置して「player01」とし、クラスを「Player」とする。
. 「Player」クラスの属性に「name」を追加し、属性値を「くぼあき」とする（ <<add_player01>> ）。

[[add_player01]]
.プレーヤー「くぼあき」を表すオブジェクト「player01」を追加した
image::GSW-20220128-053244.png[{quarter-width}]

[start=2]
. 同様にして、プレーヤー「うえはら」を表すオブジェクトを追加する（ <<add_player02>> ）。
* 既存のクラス「Player」を選ぶときは、プロパティの「ベースクラス」のプルダウンメニューから選択する（ <<add_player03>> ）。 

[[add_player02]]
.プレーヤー「うえはら」を表すオブジェクト「player02」を追加した
image::GSW-20220128-053911.png[{quarter-width}]

[[add_player03]]
.既存のクラスから「Player」クラスを選択する
image::GSW-20220128-053253.png[{half-width}]


==== オブジェクト図にスコアを追加する

こんどは、それぞれのプレーヤーのスコアを記録している部分を追加しましょう。
<<scoresheet01>> の場合、「くぼあき」さんと「うえはら」さんのスコアがありますので、オブジェクトは2つ追加します。

[[add_screr00]]
.それぞれのプレーヤーのスコアを表すオブジェクトを追加する
. パレットから「インスタンス仕様」を選択して図に配置して「score01」とし、クラスを「Score」とする。
. もうひとつ追加して「score02」とする（ <<add_score01>> ）。

[[add_score01]]
.スコアを表すオブジェクト「score01」「sore02」を追加した
image::GSW-20220128-060324.png[{quarter-width}]


==== オブジェクトのつながりを整理する

オブジェクト図に、スコアシート、ゲーム、スコア、プレーヤーのオブジェクトを追加しました。
これらはの間にはどのようなつながりがあるか考えてみましょう。

.オブジェクト同士のつながりを考える
* ワークシートは複数のゲームを記録できますので、ワークシートとゲームにはつながりがありそうです。
* ゲームでは、複数のプレーヤーのスコアを記録するので、ゲームとスコアにはつながりがありそうです。
* スコアはプレーヤーごとに記録するので、スコアとプレーヤーにはつながりがありそうです。

オブジェクトの間のつながりを表すには「リンク」を引きます。
つながりがありそうなオブジェクト同士にリンクを引いてみましょう。

まず、スコアシートとゲームの間にリンクを引きましょう。

[[add_link00]]
.「scoresheet01」から「game01」へリンクを引く
. パレットから「リンク」を選択して、「scoresheet01」の内部へマウスカーソルを移動し、青枠が表示されるのを待つ（ <<add_link01>> ）。
. 青枠が表示されたら、マウスのボタンを押したまま「game01」の内部へマウスカーソルを移動する（ <<add_link02>> ）。
. 「game01」にも青枠が表示されたら、マウスのボタンを離すとリンクが引かれる（ <<add_link03>> ）。

[[add_link01]]
.パレットからリンクを選択し、「scoresheet01」の内部へマウスカーソルを移動する
image::GSW-20220128-062909.png[{half-width}]

[[add_link02]]
.青枠が表示された状態でマウスのボタンを押し、「game01」へマウスカーソルをドラッグする
image::GSW-20220128-062951.png[{half-width}]

[[add_link03]]
.「game01」にも青枠が表示されたら、マウスのボタンを離すとリンクが引かれる
image::GSW-20220128-064800.png[{half-width}]


同様に、「game01」から「score01」、「score02」へリンクを引きます。
また、「score01」から「player01」へ、「score02」から「player02」へもリンクを引きます（ <<add_link04>> ）。

[[add_link04]]
.残りのつながりについてリンクを引く
image::GSW-20220128-065923.png[{half-width}]

もし、彼らがもう1ゲームやるとしたら、オブジェクト図は、 <<add_link05>> のようになるでしょう。

[[add_link05]]
.2ゲームやった場合のオブジェクト図
image::GSW-20220128-083544.png[{half-width}]


=== スコアシートの構造をクラス図で表す

作成したオブジェクト図 <<add_link05>> を元に、ゲームスコアのクラス図を作成してみましょう。

==== スコアシートのクラス図を追加する


まず、「ゲームスコアのクラス図」を追加します。

[[class00]]
.ゲームスコアのクラス図を追加する
* 構造ツリーで、「設計モデル」でポップアップメニューを開き、「図の追加＞クラス図」でモデルにクラス図を追加する（ <<class01>> ）。

[[class01]]
.モデルにクラス図を追加する
image::GSW-20220128-085606.png[{half-width}]

[start=2]
. 追加した図を「ゲームスコアのクラス図」とする（ <<class02>> ）。

[[class02]]
.追加した図を「ゲームスコアのクラス図」とした
image::GSW-20220128-085952.png[{half-width}]

==== クラス図にクラスを追加する

「構造ツリー」をみると、オブジェクト図を作成したとき登録した「ScoreSheet」クラスや「Game」クラスなどが見つかります。
これらを1つずつドラッグ＆ドロップして、クラス図に追加します（ <<class03>>  ）。

[[class03]]
.構造ツリーに登録されているクラスをクラス図に追加する
image::GSW-20220128-090729.png[{full-width}]

==== クラス間の関連を追加する（１）

前に作成したオブジェクト図（ <<add_link05>> ）に記載されているリンクを元に、クラス間に関連を引きます。
まず、「ScoreSheet」クラスから「Game」クラスへ向かって関連を引きましょう。

[[add_relation00]]
.クラス間の関連を追加する
. パレットから、矢印付きの関連を選択し、「ScoreSheet」クラスから「Game」クラスへ向かって関連を引く（ <<class04>> ）。

[[class04]]
.「ScoreSheet」クラスから「Game」クラスへ関連を引いた
image::GSW-20220128-091317.png[{half-width}]

[start=2]
. スコアシートには複数のゲームを記録できるので、多重度を設定する。
* <<class04>> で引いた関連を選択した状態で、プロパティからターゲットが「Game」の関連端のタブを開く。
* 「多重度」を「0..*」に設定する（ <<class05>> ）。

[[class05]]
.「ScoreSheet」からみた「Game」の多重度を「 0..* 」に設定した
image::GSW-20220128-094728.png[{three-quarters-width}]

[start=3]
. スコアシートからみたゲームを指す関連端名を設定する。
* <<class04>> で引いた関連を選択した状態で、プロパティからターゲットが「Game」の関連端のタブを開く。
* 「名前」を「games」に設定する（ <<class06>> ）。

[[class06]]
.「ScoreSheet」からみた「Game」の関連端名を「games」に設定した
image::GSW-20220128-101440.png[{three-quarters-width}]

==== クラス間の関連を追加する（１）


「head」と同様、「current」についても関連を引く（ 図 3.39 ）。

パレットから、矢印付きの関連を選択し、「 GameScore 」クラスから「 Frame 」クラスへ向かって関連を引き、関連端名をつける。

「 GameScore 」クラスからみると、まだ1投もしていないときはフレームがなく、1投して以降はフレームが複数ある。つまり、現在のフレームを指す関連のインスタンス（リンク）は、「ない」か「1つある」かのいずれかになる。この事情に見合うよう、関連の多重度を設定する。

class06
図 3.39 現在のフレームを指す関連「current」を引き、関連端名と多重度を設定した
3.2.4 クラス間の関連を追加する（２）
次に、フレーム同士の間に引かれていた「next」「prev」というリンクを関連として引きましょう。 もとのリンクは「 Frame 」クラスのインスタンスから、同じ「 Frame 」クラスのインスタンスへと引かれていました。 このようなリンクを関連に反映するときは、自クラスへつながる関連（自分から自分へ向かう関連）として表します。 また、先頭と末尾のフレームは、「nil」とつながっていました。 このようなリンクを反映するときは、つながっていない関連があるとみなします。つながっていない場合があるときは、関連の多重度に「 0 」の場合を含めます。結果として、この部分の多重度は「 0..1 」となります。

フレームからフレームへの関連を引く
「Frame 」クラスから「 Frame 」クラスへ向かって関連を引く。

パレットから矢印付きの関連を選択する。

「Frame 」クラス上でマウスをクリックして、一度カーソルをクラスから外へ出してクリックし、再び「Frame 」クラス上にカーソルを戻してクリックする（ 図 3.40 ）。

自分自身へ向かう関連が引けるので、関連の線を整える（ 図 3.41 ）。

class08
図 3.40 マウスをクラスの上でクリックし、クラスの外でクリックし、再びクラスの上でクリックする
class10
図 3.41 自分自身へ向かう関連が引けたら、関連の線を調整する
関連端名と多重度を設定する

関連端名に「prev」、多重度に「 0..1 」設定する（ 図 3.42 ）。

class11
図 3.42 関連端名と多重度を設定した
「next」についても関連端名と多重度を設定する（ 図 3.43）。

自分自身へ向かう関連を追加する。

関連端名を「next」、多重度を「 0..1 」とした。

class12
図 3.43 「next」についての関連を追加した
関連「next」と「prev」は、ひとつの双方向の関連として描くこともできます。このときは、ひとつの双方向関連の両端の関連端名を「next」と「prev」とします（ 図 3.44 ）。

class13
図 3.44 関連「next」と「prev」をひとつの双方向関連で表した場合


== スコアの状態を調べる

[.lead]
スコアをつける手順に従うとき、スコアにはどのような状態があるのでしょうか。

==== フレームについて検討する




==== 10フレーム目の扱いについて検討する

「クラッシックスコアリング」の場合、10フレーム目が他のフレームとは異なっています。
サービスフレームという考え方があり、ストライクやスペアの場合に追加で投球できます。

このサービスフレームの扱い方にについて整理しておきましょう。

===== 10フレーム目がストライクもスペアもない場合

10フレーム目がストライクでもスペアもない場合、9フレーム目までの通常のフレームと同様、1投目と2投目を記録するだけです（ <<ten_no_service>>  ）。
サービスフレームは追加されません。

[[ten_no_service]]
.10フレーム目がストライクもスペアもない場合
image::ten_no_service_combo.png[{half-width}]

===== 10フレーム目がスペアの場合

10フレーム目の2投目でスペアになった場合、1投目と2投目を通常のフレームと同様に記録したのち、もう1投追加されます。
これを、10フレーム目に加えて、11フレーム目の1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_spare_service>> 」のように構成します。

[[ten_spare_service]]
.10フレーム目がスペアの場合
image::ten_spare_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


===== 10フレーム目の1投目がストライクの場合

10フレーム目の1投目がストライクの場合、10フレーム目をストライクとした上で、もう2投追加されます。
これを、10フレーム目に加えて、11フレーム目の1投目と2投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_one_strike_service>> 」のように構成します。
だたし、11フレーム目の1投目がストライクの場合は、同じ2投追加でも次の「2投目もストライクの場合」の考え方を使います。

[[ten_one_strike_service]]
.10フレーム目の1投目がストライクの場合
image::ten_one_strike_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。

===== 10フレーム目の2投目もストライクの場合

10フレーム目の2投目もストライクの場合、10フレーム目、11フレーム目をストライクとした上で、もう1投追加されます。
これを、10フレーム目、11フレーム目に加えて、12フレーム目の1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_two_strike_service>> 」のように構成します。
このように構成すれば、通常のフレームでダブルをとったときの計算方法（ストライクが続いたときはさらに次のフレームの1投目が2投目として加算される）のままで10フレーム目のボーナスが計算できます。

[[ten_two_strike_service]]
.10フレーム目の2投目もストライクの場合
image::ten_two_strike_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


=== 解決したいのはゲームの進行とスコアの計算

ユースケース吟味した結果、自動化によって解決したかったのは、ゲームの状態を把握することで「ゲームを進める」ときのスコアラーの入力を簡便にすることだとわかりました。
また、「スコアを計算する」こと、とりわけ「ストライクボーナスやスペアボーナスのを計算すること」だとわかりました。

このような検討結果から、このチュートリアルでは「スコアを記録する」というユースケースを実現することを目標にします。
とくに、「ゲームを進める」ことと「ボウリングのスコアを計算する」ことについて、モデルを使って表現し、そのモデルからプログラムを得るように努めます。

スコアのつけ方については、これまで検討してきた「クラッシックスコアリング」を対象としましょう。
「カレントフレームスコアリング」に比べて、フレームの間に依存関係がある分、スコア計算がより複雑になっています。
