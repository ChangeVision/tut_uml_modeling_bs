ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_requirement_anaylysis]]
== 解決したい課題はなにか

[.lead]
スコアをつけるときの解決したい課題はなんでしょうか。
スコアをつけるときの手順を整理しながら、考えてみましょう。


=== 手動のときの手順を整理する


スコアを手でつけていたときは、スコアを計算してスコアシートに記録するのは、スコアラーの仕事です。
スコアラーになった人は、ゲームの様子を観察して倒れたピン数を確認し、スコアをつけるルールに従ってスコアをつけます。
仲間うちでやるときは、投球する順番がきているプレーヤーがボールを投げている間、手の空いている他のプレーヤーが交代でスコアラーになってスコアをつけます。

このときのプレーヤーとスコアラーの関係を「ユースケース図」で表してみましょう。
ユースケース図は、関心の対象となっている業務やシステムが提供したい機能やサービスと、それらを利用する人や外部のサービス等の関係を表すために使います。

[TIP]
--
機能やサービスを提供する主体のことを、ユースケース図では「システム」と呼ぶことが多いです。
そのサービスが人によって実施される作業を含んでいても、それらのサービスを提供する範囲をシステムと呼びます。
--

==== プロジェクトに分析モデルを追加する

まず、プロジェクトに分析モデルを追加しましょう。
ここで言う分析モデルは、分析用に作成するモデル図を格納する場所だと思ってください。

[TIP]
--
ここでの分析とは、対象とする業務やサービスを詳しく調べて、役割を持つ複数の要素に分けることだと考えておけばよいでしょう。
--

[[add_analysis_model]]
.プロジェクトに分析モデルを追加する
. プロジェクトにモデルを追加する。
** 構造ツリー上で、プロジェクトを選択する。
** 右クリックしてポップアップメニューを開き、「モデルの追加＞モデル」を選択する（ <<add_analysis_model01>> ）。

[[add_analysis_model01]]
.プロジェクトにモデルを追加した
image::add_analysis_model01.png[{half-width}]


[start=2]
. 追加したモデルに名前をつける
** 構造ツリー上で、追加したモデルを選択した状態で、プロパティの「ベース」タブを選択する。
** 「名前」を編集して「01_分析モデル」とする（ <<add_analysis_model02>> ）。

[[add_analysis_model02]]
.モデルに分析用のモデルとして名前をつけた
image::add_analysis_model02.png[{half-width}]

[TIP]
--
モデル名の前に「 `01_` 」とつけたのは、今後作成するモデルを自分の考える順に並ばせるための工夫です。
--

==== 分析モデルにユースケース図を追加する

次に、分析モデルにユースケース図を追加して、手動でスコアをつけているときのユースケース図を描いてみましょう。

[[add_use_case_chart]]
.モデルにユースケース図を追加する
. 構造ツリー上で、「01_分析モデル」を選択する。
. 右クリックしてポップアップメニューを開き、「図の追加＞ユースケース図」を選択する（ <<create_use_case03>> ）。

[[create_use_case03]]
.モデルにユースケース図を追加する
image::create_use_case03.png[{half-width}]

[start=3]
. 追加した図に名前をつける。
** 構造ツリー上で、追加したユースケース図を選択した状態で、プロパティの「ベース」タブを選択する。
** 「名前」を編集して「手動でスコアをつけているときのユースケース図」とする（ <<create_use_case04>> ）。

[[create_use_case04]]
.プロジェクトにユースケース図が追加できた
image::create_use_case04.png[{three-quarters-width}]

これで、プロジェクトにユースケース図が追加できました。

==== ユースケース図にアクターを追加する

ユースケース図が追加できましたので、こんどはユースケース図にアクターとユースケースを追加しましょう。


ユースケース図では、システムが提供する機能やサービスを「ユースケース」を呼びます。
そのユースケースを利用する、外部の人や外部のサービスのことを「アクター」と呼びます。

[TIP]
--
アクターは人とは限りません。外部の機器や、サービスを提供する別のシステムの場合もあります。
--

まず、アクターについて考えてみましょう。
スコアラーにスコアを計算して記録してもらっているのはプレーヤーですね。
つまり、このシステムからサービスを享受しているアクターはプレーヤーだとみなせそうです。

追加したユースケース図にアクター「プレーヤー」を追加しましょう。

.アクター「プレーヤー」を追加する
--
. パレットからアクターのシンボル（人型のアイコン）を選択する（ <<add_actor01>> ）。

[[add_actor01]]
.パレットからアクターを選択する
image::add_actor01.png[{half-width}]

[start=2]
. 図の中でマウスをクリックすると、アクターが追加される（ <<add_actor02>> ）。

[[add_actor02]]
.アクターが追加された
image::add_actor02.png[{half-width}]

[start=3]
. アクターの名前を編集する。
** アクターの名前が選択されている状態（ <<add_actor03>> ）で「プレーヤー」に変更する。
** または、アクターが選択されている状態で、プロパティの「名前」欄を編集する（ <<add_actor04>> ）。

[[add_actor03]]
.アクターの名前を編集する（直接編集）
image::add_actor03.png[{half-width}]

[[add_actor04]]
.アクターの名前を編集する（プロパティから編集）
image::add_actor04.png[{half-width}]
--

これで、ユースケース図にアクター「プレーヤー」が追加できました。

[NOTE]
--
あるシステムに対して、アクターはひとつとは限らず、複数見つかる場合もあります。
また、同じ利用者であっても、いくつかの役割や立場からシステムを利用する場合もあります。
アクターは、役割ごとに用意し、役割が分かる名前をつけるようにしましょう。
--

==== ユースケース図にユースケースを追加する

次に、ユースケースについて考えてみましょう。
いま分析しているのは、手動でスコアをつけているスコアラーの仕事でしたね。
つまり、システムとして捉えようとしているのは、スコアラーが担当する仕事というわけです。
これは、このユースケース図そのものが表そうとしていることでもあります。

このような捉え方をした上で、スコアラー（システム）がプレーヤー（アクター）に提供しているサービスにあたるものを考えます。
すると、「プレーヤーが倒したピン数を取得して、スコアを計算し、スコアシートに記録する」という一連の処理がこれにあたりますね。
この一連の処理に「スコアをつける」という名前をつけましょう。これを「ユースケース」と呼びます。

追加したユースケース図にユースケース「スコアをつける」を追加しましょう。


.ユースケース「スコアをつける」を追加する
--
. パレットからユースケースのシンボル（楕円のアイコン）を選択する（ <<add_use_case01>> ）。

[[add_use_case01]]
.パレットからユースケースを選択する
image::add_use_case01.png[{half-width}]

[start=2]
. 図の中でマスをクリックすると、ユースケースが追加される（ <<add_use_case02>> ）。

[[add_use_case02]]
.ユースケースが追加された
image::add_use_case02.png[{half-width}]

[start=3]
. ユースケースの名前を編集する。
** ユースケースの名前が選択されている状態（ <<add_use_case03>> ）で「スコアをつける」に変更する。
** または、ユースケースが選択されている状態で、プロパティの「名前」欄を編集する（ <<add_use_case04>> ）。

[[add_use_case03]]
.ユースケースの名前を編集する（直接編集）
image::add_use_case03.png[{half-width}]

[[add_use_case04]]
.ユースケースの名前を編集する（プロパティから編集）
image::add_use_case04.png[{full-width}]
--

これで、ユースケース図にユースケース「スコアをつける」が追加できました。


==== アクターとユースケースを関連づける

これまでのところ、アクターとユースケースがひとつずつですので、これらが互いに関連しているとみなすのは容易です。
しかし、複数のアクターや複数のユースケースがあると、どのアクターがどのユースケースを利用するのかわなくなってしまうでしょう。
そこで、アクターと、そのアクターが利用するユースケースの間に関連の線を引いて、ユースケースとアクターを関連づけます。

アクター「プレーヤー」とユースケース「スコアをつける」の間に関連を引いてみましょう。


.アクター「プレーヤー」とユースケース「スコアをつける」を関連づける
--
. パレットから関連のシンボル（横線のアイコン）を選択する（ <<add_use_case_rel01>> ）。

[[add_use_case_rel01]]
.パレットから関連を選択する
image::add_use_case_rel01.png[{half-width}]

[start=2]
. アクター「プレーヤー」の内部（周辺ではなくシンボル上）でへマウスをクリックする。
** 青い枠線が現れるのを待つ。
** 枠線が現れたら、マウスをドラックすると赤い線が現れる（ <<add_use_case_rel02>> ）。

[[add_use_case_rel02]]
.関連を引き始める
image::add_use_case_rel02.jpg[{half-width}]

[start=3]
. 赤い線を引いたまま、マウスをユースケース「スコアをつける」の内部まで移動する。
** 青い枠線が現れるのを待つ（ <<add_use_case_rel03>> ）。
** マウスをクリックすると関連が引かれる。


[[add_use_case_rel03]]
.関連が引かれた
image::add_use_case_rel03.png[{half-width}]
--

これで、アクター「プレーヤー」とユースケース「スコアをつける」の間に関連が引けました。

このユースケース図は、システムとして表しているのはスコアラーの仕事で、プレーヤーに対してひとつのサービス「スコアをつける」を提供していると読めます。

==== ユースケース記述を追加する

ユースケース図の上では、ユースケースやアクターはそれらの名前しか記載しません。
そのため、ユースケースの詳しい内容（どのような仕事をするのか）はよくわかりません。
そこで、ひとつのユースケースに対して、そのユースケースの一連の処理の流れを説明した記述をひとつ書きます。
これを「ユースケース記述」と呼びます。

ユースケース「スコアをつける」のユースケース記述を考えてみました。
スコアの計算はスコアラーの頭の中でやります。スコアを記録する作業もスコアラーの手作業です。
そうすると、プレーヤーとスコアラーの間でのやりとりは、ピン数のやりとりだけですので、ユースケース記述は「 <<use_case_desc00>> 」のようになるでしょう。

[[use_case_desc00]]
.ユースケース「スコアをつける」のユースケース記述
[example]
--
. プレーヤーは、投球する。
. プレーヤーは、スコアラーに倒したピン数を申告する。
. スコアラーは、スコアを計算して、スコアシートに記録する。
. ゲームの終了まで、1から3を繰り返す。
--

{astah} には、ユースケース記述を記述するエディタが用意してあります。

ユースケース記述エディタを使って「 <<use_case_desc00>> 」のユースケース記述を書いてみましょう。

.ユースケース記述エディタを使ってユースケース記述を書く
--
. ユースケース記述エディタを開く。
** ユースケース「スコアをつける」をマウスを右クリックして、ポップアップメニューを表示する。
** 「ユースケース記述を開く」を選択する。

[[use_case_desc01]]
.ユースケース記述エディタを開く
image::use_case_desc01.png[{three-quarters-width}]

. ユースケース記述を書く。
** 「基本系列」に「 <<use_case_desc00>> 」に記載した内容を書き込む

[[use_case_desc02]]
.ユースケース「スコアをつける」のユースケース記述
image::use_case_desc02.png[{half-width}]
--

[TIP]
--
「ユースケース記述エディタ」の記述項目には、基本系列のほかに、代替系列、事前条件などの記述項目があります。
これらの項目のうち、この演習では基本系列だけ使っています。
他の項目の使い方を学ぶのは、もう少し慣れてからでよいでしょう。
--

簡便に記述する方法として、「ユースケース記述エディタ」を使う代わりに、「ノート」を使って書く方法を紹介しておきます。

ノートは、UMLの図を作成するときに、補助的な説明をつけるために用意されている要素で、耳を折った矩形で表します。

ノートは、モデルの要素に対して、捕捉する説明をつけたいときに使います。
ここでは、ユースケース「スコアをつける」は、どのような手順なのかを説明しています。

ノートを追加して、「 <<use_case_desc00>> 」のユースケース記述を書いてみましょう。

.ノートを使ってユースケース記述を書く
--
. パレットからノートのシンボル（耳が折れた矩形のアイコン）を選択する（ <<use_case_desc03>> ）。

[[use_case_desc03]]
.パレットからノートを選択する
image::use_case_desc03.png[{half-width}]

[start=2]
. 図の中でマスをクリックすると、ノートが追加される（ <<use_case_desc04>> ）。

[[use_case_desc04]]
.ノートが追加された
image::use_case_desc04.png[{half-width}]

[start=3]
. ユースケース記述を編集する。
** ノートが選択されている状態（ <<use_case_desc04>> ）で、プロパティを編集して、ユースケース記述を書く（ <<use_case_desc05>> ）。

[[use_case_desc05]]
.ノートにユースケース記述を書く
image::use_case_desc05.png[{full-width}]

[start=4]
. ノートからユースケースへアンカーを引く（ <<use_case_desc06>> ）。
** パレットから、ノートからユースケースへのアンカーを選択する。
** ノートの内部へマウスを移動すると、ノートに青枠が現れる。
** マウスのボタンをクリックし、マウスをユースケースの内部へ移動する。
** ユースケースに青枠が現れたら、マウスクリックすると、アンカーが引かれる。

[[use_case_desc06]]
.ノートからユースケースへアンカーを引く
image::use_case_desc06.jpg[{half-width}]
--


できあがったユースケースは「 <<use_case01>> 」のようになるでしょう。


[[use_case01]]
.手動でスコアをつけているときの（スコアラーの働きを表している）ユースケース図
image::use_case01.svg[{half-width}]

この図は、「スコアラー（システム）は、プレーヤー（アクター）にスコアをつけるというサービスを提供する」と読めます。そして、「スコアをつける」の詳細はノートを使ったユースケース記述に記載しています。


[NOTE]
--
一般に、ユースケースやアクターはひとつだけとは限らないことに注意しましょう。
これまでの分析結果において、アクター「スコアラー」とユースケースは「スコアをつける」だけが見つかっているので、「 <<use_case01>> 」のような図になっているのです。
--

=== 自動化されてからの手順を整理する


「<<use_case01>> 」は、手でスコアをつけている場合を表していました。
このままでは、人がやっている仕事をそのまま表しているだけですね。
こんどは、スコアラーがスコアをつける手順に着目して、スコアをつける作業の一部を自動化して助けてくれるサービスを想定してみましょう。つまり、こんどは、スコアラーに提供するサービスを考えることになります。


そうすると、「 <<use_case01>> 」とはユースケース図の構成が変わってきます。
スコアラーに提供するサービスを考えてみるわけですから、スコアラーがアクターになりますね。

このように捉えた場合のユースケース図を描いてみましょう。

「<<add_use_case_chart>>」と同じ手順で、「01_分析モデル」の中にユースケース図を追加します。
図の名前は「スコアをつけるところを助けてくれるサービスを考えたユースケース図」としておきましょう（ <<use_case02>> ）。

[[use_case02]]
.分析モデルにユースケース図を追加する
image::use_case02.png[{half-width}]

まず、アクターが「スコアラー」なのは明らかですので、スコアラーを追加しましょう（これはもうできますね）。

次に、スコアラーに提供するサービスを表すユースケースを考えてみましょう。
顧客から依頼されている場合であれば、顧客から収集した現状の業務や改善の要求から導出するところです。
ここでは、スコアラーがスコアをつけるときに、スコアを計算したり記録する部分を助けてもらいたいのでした。
これをユースケースとするのがよさそうです。

ユースケース名は「スコアを（スコアラーに代わって）記録する」にしましょう。

ユースケース記述は、「 <<use_case_desc07>> 」のようになるでしょう。

[[use_case_desc07]]
.ユースケース「スコアを記録する」のユースケース記述
[example]
--
. スコアラーは、プレーヤーが投球するたびに、ピン数をシステムに入力する。
. システムは、スコアシートの状況に応じて、ピン数を記録する。
. 前のフレームのストライクやスペアのボーナスを計算する。
. ゲームが終わるまで、1から3を繰り返す。
--

作成したユースケース図は「 <<use_case03>>  」のようになるでしょう。

[[use_case03]]
.スコアをつけるところを助けてくれるサービスを考えたユースケース図
image::use_case03.svg[{three-quarters-width}]

以上の分析の結果、このチュートリアルで作成するシステムは、「スコアラーが使う」「スコアを記録する」システムということがわかりました。

=== ユースケースを吟味する

こんどは、ユースケース「スコアを記録する」について、もう少し詳しく検討してみましょう。

スコアを記録するときの、スコアラーとシステムの間のやり取りや、入力されたピン数をシステムがどのように扱うのかを検討するために「ロバストネス図」を使ってみましょう。

.ロバストネス分析とロバストネス図
****
ロバストネス図は、システムの構成要素を分析する「ロバストネス分析」で使用する図です。
ロバストネス分析では、システムを構成する要素は「バウンダリ」「エンティティ」「コントロール」の3種類に大別できると考え、該当する要素がないか想定して構成要素を探します。
また、これらの要素間の繋がりには制約があると考えることで、構成要素を探しやすくします。

// .ロバストネス図に使うシンボル
// * image:robustness_entity_icon.jpg[{thumbnail}]
// * image:robustness_control_icon.jpg[{thumbnail}]
// * image:robustness_boundary_icon.jpg[{thumbnail}]


ロバストネス図で抽出した要素は、クラスの候補になります。
ただし、ひとつの要素がそのままひとつのクラスになるとは限りません。
複数の要素を組み合わせてクラスに仕立てるといったこともあります。

ロバストネス分析とロバストネス図の詳しい説明は、「ワークブック形式で学ぶUMLオブジェクトモデリング <<robustness01>> 」や「ユースケース駆動開発実践ガイド <<robustness02>> 」などを参照してください。
****


==== プロジェクトにロバストネス図を追加する

まず、アクター「スコアラー」とシステムの間のやりとりを検討するためのロバストネス図を作成しましょう。
そこで、プロジェクトにロバストネス図を追加します。
分析の続きですので、「01_分析モデル」に追加しましょう。
ロバストネス図はクラス図の表記を応用した図なので、 {astah} で作成するときはクラス図を使います。

.分析モデルにロバストネス図を追加する
--
. モデルにクラス図を追加する。
** 構造ツリー上で、「01_分析モデル」を選択する。
** 右クリックしてポップアップメニューを開き、「図の追加＞クラス図」を選択する。（ <<add_robustness01>> ）。

[[add_robustness01]]
.モデルにクラス図を追加する
image::add_robustness01.png[{half-width}]

[start=2]
. 追加した図に名前をつける。
** 構造ツリー上で、追加したクラス図を選択した状態で、プロパティの「ベース」タブを選択する。
** 「名前」を編集して「スコアラーとシステムの間のロバストネス図」とする（ <<add_robustness02>> ）。

[[add_robustness02]]
.モデルにロバストネス図が追加できた
image::add_robustness02.png[{half-width}]
--

これで、ロバストネス図が描けるようになりました。

==== 新しいゲームを用意する

新しいゲームを始めるとき、スコアラーが手で書いていたときは、スコアシートを用意してゲームに参加する人の名前を書くといった準備をします。

スコアを記録する部分を自動化した場合、新しいゲームを用意するためにはどのような要素が必要になるでしょうか。
ロバストネス図を使って検討してみましょう。

まず、アクター「スコアラー」を追加しましょう。

.ロバストネス図にアクターを追加する
--
. 構造ツリー上から追加したロバストネス図をダブルクリックして、編集できる状態にします（ <<add_actor_on_robustness01>> ）。

[[add_actor_on_robustness01]]
.追加したロバストネス図を編集可能にする
image::add_actor_on_robustness01.png[{half-width}]

[start=2]
. スコアラーは、作成済みで構造ツリー上にありますので、これをドラッグ＆ドロップして追加します（ <<add_actor_on_robustness02>> ）。

[[add_actor_on_robustness02]]
.追加したロバストネス図を編集可能にする
image::add_actor_on_robustness02.png[{full-width}]
--

次に、スコアラーが新しいゲームを用意するときにシステムとやりとりする場合に必要な要素を、ロバストネス図のシンボルを使って表してみます。

新しいゲームを始めるときは、スコアラーがシステムに新しいゲームを用意する指示を出します。
このことを実現するには、システムには、指示を受け取るためのインターフェースと新しいゲームを用意する処理が必要になります。

これらをロバストネス図に追加してみましょう。

.新しいゲームを用意するための要素を追加する
--
. バウンダリ「ゲーム開始指示入力」を追加する（ <<add_boundary01>> ）。
** パレットからバウンダリのシンボルを選択し、ロバストネス図に追加する。
** 追加したバウンダリの名前を「ゲーム開始指示入力」とする。
** アクター「スコアラー」とバウンダリ「ゲーム開始指示入力」の間に関連を引く。

[[add_boundary01]]
.バウンダリ「ゲーム開始指示入力」を追加する
image::add_boundary01.png[{half-width}]

[start=2]
. コントロール「新しいゲームを用意する」を追加する（ <<add_control01>> ）。
** パレットからコントロールのシンボルを選択し、ロバストネス図に追加する。
** 追加したコントロールの名前を「新しいゲームを用意する」とする。
** バウンダリ「ゲーム開始指示入力」とコントロール「新しいゲームを用意する」の間に関連を引く。

[[add_control01]]
.コントロール「新しいゲームを用意する」を追加する
image::add_control01.png[{half-width}]

[start=3]
. エンティティ「ゲームスコア」を追加する（ <<add_entity01>> ）。
** パレットからエンティティのシンボルを選択し、ロバストネス図に追加する。
** 追加したエンティティの名前を「ゲームスコア」とする。
** コントロール「新しいゲームを用意する」とエンティティ「ゲームスコア」の間に関連を引く。

[[add_entity01]]
.エンティティ「ゲームスコア」を追加する
image::add_entity01.png[{three-quarters-width}]

--

これで、スコアラーが新しいゲームを始める指示を出したとき、システムが新しいゲームを用意するのに必要な要素が洗い出せました。

==== ゲームを進める

こんどは、ゲームを進めているときに必要な要素を検討してみましょう。

スコアラーがスコアシートを手で書いていたときは、スコアラーはいまどのフレームの何投目であるかを意識して書いていたでしょう。
一方、スコアの記録を自動化した場合は、どのフレームの何投目なのかはシステムに把握しておいてほしいでしょう。
そうしておけば、スコアラーは単にピン数を入力すれば済むようになります。

そして、システムは、ピン数を取得するたびにゲームを進めます。
ピン数を取得するたびに、ゲームスコアを更新し、更新したスコアをスコアラーへ返せばよさそうです。

これらをロバストネス図に追加してみましょう。

.ゲームを進めるための要素を追加する
--
. バウンダリ「ピン数入力」を追加する（ <<add_boundary02>> ）。
** パレットからバウンダリのシンボルを選択し、ロバストネス図に追加する。
** 追加したバウンダリをの名前を「ピン数入力」とする。
** アクター「スコアラー」とバウンダリ「ピン数入力」の間に関連を引く。

[[add_boundary02]]
.バウンダリ「ピン数入力」を追加する
image::add_boundary02.png[{three-quarters-width}]

[start=2]
. コントロール「ゲームを進める」を追加する（ <<add_control02>> ）。
** パレットからコントロールのシンボルを選択し、ロバストネス図に追加する。
** 追加したコントロールの名前を「ゲームを進める」とする。
** バウンダリ「ピン数入力」とコントロール「ゲームを進める」の間に関連を引く。
** コントロール「ゲームを進める」とエンティティ「ゲームスコア」との間に関連を引く。

[[add_control02]]
.コントロール「ゲームを進める」を追加する
image::add_control02.png[{three-quarters-width}]

[start=3]
. バウンダリ「ゲームスコア出力」を追加する（ <<add_boundary03>> ）。
** パレットからバウンダリのシンボルを選択し、ロバストネス図に追加する。
** 追加したバウンダリの名前を「ゲームスコア出力」とする。
** アクター「スコアラー」とバウンダリ「ゲームスコア出力」の間に関連を引く。

[[add_boundary03]]
.バウンダリ「ゲームスコア出力」を追加する
image::add_boundary03.png[{three-quarters-width}]

[start=4]
. コントロール「ゲームスコアを出力する」を追加する（ <<add_control03>> ）。
** パレットからコントロールのシンボルを選択し、ロバストネス図に追加する。
** 追加したコントロールの名前を「ゲームスコアを出力する」とする。
** バウンダリ「ゲームスコア出力」とコントロール「ゲームスコアを出力する」の間に関連を引く。
** コントロール「ゲームスコアを出力する」とエンティティ「ゲームスコア」の間に関連を引く。
** コントロール「ゲームを進める」とコントロール「ゲームスコアを出力する」の間に関連を引く。

[[add_control03]]
.コントロール「ゲームスコアを出力する」を追加する
image::add_control03.png[{three-quarters-width}]

--

これで、スコアラーがピン数を入力したとき、ゲームを進め、ゲームスコアを更新するに必要な要素が洗い出せました。
また、ゲームが進んだ際に、更新したゲームスコアを出力するのに必要な要素も洗い出せました。

==== スコアを計算する

スコアを記録したり、更新したスコアを出力できるようにはなりましたが、まだスコアの計算を自動化するために必要な要素が洗い出せていません。
そこで、こんどはスコアを計算する処理について検討してみましょう。

.スコアの計算の検討に使うロバストネス図を追加する
--
. モデルにクラス図を追加し、追加した図を「スコアの計算に関するロバストネス図」とする（ <<add_robustness03>> ）。

[[add_robustness03]]
.モデルにスコア計算に関するロバストネス図を追加する
image::add_robustness03.png[{half-width}]
--

スコアの計算に必要となりそうなエンティティとしては、「ゲームスコア」「現在のフレーム」「ゲームの状態」などがありそうです。
ゲームの状態としては、1投目、2投目、サービスフレーム中、ゲームの終了といった状態が考えられます。

スコアの計算をするコントロールと、これらのエンティティを追加します。

.スコアを計算するコントロールと関連するエンティティを追加する
--
. コントロール「スコアを計算する」ならびに関連するエンティティを追加する（ <<add_control04>> ）。
** パレットからコントロールのシンボルを選択して追加し、「スコアを計算する」とする。
** エンティティ「ゲームスコア」を構造ツリーからドラッグ＆ドロップして追加する。
** パレットからエンティティのシンボルを選択して追加し、「現在のフレーム」とする。
** パレットからエンティティのシンボルを選択して追加し、「ゲームの状態」とする。
** コントロール「スコアをを計算する」から、それぞれのエンティティへ関連を引く。

[[add_control04]]
.コントロール「スコアを計算する」を追加する
image::add_control04.png[{full-width}]

--


さらに、スコアを計算して記録するには、エンティティ「ゲームスコア」に対して計算の結果を記録するためのフレームを追加する処理が必要です。この処理をコントロールとして追加しましょう。
スコアの計算では、ストライクボーナスとスペアボーナスの計算がありますが、これらも明示的に用意しておきましょう。

.スコアを計算するコントロールと関連するコントロールを追加する
--
. コントロール「フレームを追加する」を追加する（ <<add_control05>> ）。
** パレットからコントロールのシンボルを選択して追加し、「フレームを追加する」とする。
** コントロール「スコアをを計算する」からコントロール「フレームを追加する」へ関連を引く。
** コントロール「フレームを追加する」からエンティティ「ゲームスコア」へ関連を引く。

[[add_control05]]
.コントロール「フレームを追加する」を追加する
image::add_control05.png[{three-quarters-width}]

[start=2]
. ボーナスの計算を追加する（ <<add_control06>> ）。
** パレットからコントロールのシンボルを選択して追加し、「ストライクボーナスを計算する」とする。
** パレットからコントロールのシンボルを選択して追加し、「スペアボーナスを計算する」とする。
** コントロール「スコアをを計算する」からコントロール「ストライクボーナスを計算する」へ関連を引く。
** コントロール「スコアをを計算する」からコントロール「スペアボーナスを計算する」へ関連を引く。
** コントロール「ストライクボーナスを計算する」からエンティティ「ゲームスコア」へ関連を引く。
** コントロール「スペアボーナスを計算する」からエンティティ「ゲームスコア」へ関連を引く。


[[add_control06]]
.コントロール「ストライクボーナスを計算する」と「スペアボーナスを計算する」を追加する
image::add_control06.png[{three-quarters-width}]

--

これで、スコアを計算するのに必要な要素が洗い出せました。


==== システム全体を整理する

これまでに作成した「スコアラーとシステムの間のロバストネス図（ <<add_robustness02>> ）」と「スコアの計算に関するロバストネス図（ <<add_robustness03>> ）」をまとめると、システムのロバストネス図が作成できます。

エンティティ「ゲームスコア」は同じものですので、ひとつにまとめましょう。
コントロール「スコアを計算する」はコントロール「ゲームを進める」の処理のなかで利用すると考えられますので、これらを関連づけます。


.作成したロバストネス図をひとつにまとめる
--
. モデルにクラス図を追加し、追加した図を「システムのロバストネス図」とする（ <<add_robustness04>> ）。

[[add_robustness04]]
.モデルにシステムのロバストネス図を追加する
image::add_robustness04.png[{half-width}]

[start=2]
. ロバストネス図「スコアラーとシステムの間のロバストネス図」に記載した要素を取り込む。
** ロバストネス図「スコアラーとシステムの間のロバストネス図」 を開き、作成した要素をすべてコピーする。
** ロバストネス図「システムのロバストネス図」を開き、ペーストする（ <<add_robustness08>> ）。

[[add_robustness08]]
.システムのロバストネス図に2つのロバストネス図をペーストする
image::add_robustness08.png[{full-width}]

[start=3]
. ロバストネス図「スコア計算に関するロバストネス図」に記載した要素を取り込む。
** ロバストネス図「スコア計算に関するロバストネス図」を開き、、作成した要素をすべてコピーする。
** ロバストネス図「システムのロバストネス図」を開き、ペーストする。
** 2つあるエンティティ「ゲームスコア」のうち一方を選択し、右クリックしてポップアップメニューを開く。
** メニューから「図から削除」を選択し、エンティティ「ゲームスコア」のうち一方を消す（ <<add_robustness05>> ）。

[[add_robustness05]]
.重複するエンティティ「ゲームスコア」の一方を消す
image::add_robustness05.png[{three-quarters-width}]

[start=4]
. 残した方の「ゲームスコア」と他方につかがっていたコントロールの間に関連を引く（ <<add_robustness06>> ）。


[[add_robustness06]]
.残したエンティティ「ゲームスコア」とコントロールの間に関連を引く
image::add_robustness06.png[{full-width}]

[start=5]
. コントロール「ゲームを進める」とコントロール「スコアを計算する」の間に関連を引く。


[[add_robustness07]]
.コントロール「ゲームを進める」とコントロール「スコアを計算する」ントロールの間に関連を引く
image::add_robustness07.png[{full-width}]

--

最後にできあがったロバストネス図から、このシステムにはどのような要素が必要なのかわかってきました。

==== スコア計算を含むユースケース記述を書く

作成したロバストネス図に登場する要素を参考にして、ユースケース記述を見直してみましょう。

ロバストネス図を作成した結果、ユースケース「スコアを記録する」には、次のような働きが含まれていることがわかりました。

* スコアを計算する
* （ゲームスコアに）フレームを追加する
* ストライクボーナスを計算する
* スペアボーナスを計算する

このことを加味して、ユースケース「スコアを記録する」のユースケース記述（ <<use_case_desc07>> ）を見直してみましょう（ <<use_case_desc08>> ）。


[[use_case_desc08]]
.ユースケース「スコアを記録する」のユースケース記述（見直し後）
[example]
--
. スコアラーがゲームの開始指示を出すと、システムは新しいゲームを用意する。
. スコアラーは、プレーヤーが投球した結果をみてピン数をシステムに入力する。
. システムは、ピン数を受け取ると、ゲームを進め、ユースケース「スコアを計算する」を実行する。
.. 現在の状態が、1投目のピン数入力待ちのとき:
*** ゲームスコアに新しいフレームを追加する。
*** 現在のフレームの1投目にピン数を記録する。
*** 1投目がストライクだったときは、現在の状態を次の1投目のピン数入力待ちに変更する。
*** ストライクでなかったときは、現在の状態を2投目のピン数入力待ちに変更する。
.. 現在の状態が、2投目のピン数入力待ちのとき:
*** 現在のフレームの2投目にピン数を記録する。
*** 現在の状態を次の1投目のピン数入力待ちに変更する。
. スペアボーナスを計算し、ゲームスコアに反映する。
.. 前のフレームがスペアのとき:
*** 1投目のピン数を前のフレームのスペアボーナスに記録する。
. ストライクボーナスを計算し、ゲームスコアに反映する。
.. 前のフレームがストライクのとき:
*** 1投目と2投目のピン数の合計を前のフレームのストライクボーナスに記録する。
.. 前の前のフレームがストライクのとき:
*** 1投目のピン数と前のフレームの1投目のピン数を、前の前のフレームのストライクボーナスに記録する。
. 10フレームになったときは、サービスフレームを追加する。
. 上記2から6を、10フレームになるまで繰り返す。
--

==== 10フレーム目の扱いについて検討する

「クラッシックスコアリング」の場合、10フレーム目が他のフレームとは異なっています。
サービスフレームという考え方があり、ストライクやスペアの場合に追加で投球できます。

このサービスフレームの扱い方にについて整理しておきましょう。

===== 10フレーム目がストライクもスペアもない場合

10フレーム目がストライクでもスペアもない場合、9フレーム目までの通常のフレームと同様、1投目と2投目を記録するだけです（ <<ten_no_service>>  ）。
サービスフレームは追加されません。

[[ten_no_service]]
.10フレーム目がストライクもスペアもない場合
image::ten_no_service_combo.png[{half-width}]

===== 10フレーム目がスペアの場合

10フレーム目の2投目でスペアになった場合、1投目と2投目を通常のフレームと同様に記録したのち、もう1投追加されます。
これを、10フレーム目に加えて、11フレーム目の1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_spare_service>> 」のように構成します。

[[ten_spare_service]]
.10フレーム目がスペアの場合
image::ten_spare_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


===== 10フレーム目の1投目がストライクの場合

10フレーム目の1投目がストライクの場合、10フレーム目をストライクとした上で、もう2投追加されます。
これを、10フレーム目に加えて、11フレーム目の1投目と2投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_one_strike_service>> 」のように構成します。
だたし、11フレーム目の1投目がストライクの場合は、同じ2投追加でも次の「2投目もストライクの場合」の考え方を使います。

[[ten_one_strike_service]]
.10フレーム目の1投目がストライクの場合
image::ten_one_strike_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。

===== 10フレーム目の2投目もストライクの場合

10フレーム目の2投目もストライクの場合、10フレーム目、11フレーム目をストライクとした上で、もう1投追加されます。
これを、10フレーム目、11フレーム目に加えて、12フレーム目の1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_two_strike_service>> 」のように構成します。
このように構成すれば、通常のフレームでダブルをとったときの計算方法（ストライクが続いたときはさらに次のフレームの1投目が2投目として加算される）のままで10フレーム目のボーナスが計算できます。

[[ten_two_strike_service]]
.10フレーム目の2投目もストライクの場合
image::ten_two_strike_combo.png[{half-width}]

ゲームスコアをこのように構成しておくと、10フレーム目も、通常フレームの組み合わせによってボーナスも計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


=== 解決したいのはゲームの進行とスコアの計算

ユースケース吟味した結果、自動化によって解決したかったのは、ゲームの状態を把握することで「ゲームを進める」ときのスコアラーの入力を簡便にすることだとわかりました。
また、「スコアを計算する」こと、とりわけ「ストライクボーナスやスペアボーナスのを計算すること」だとわかりました。

このような検討結果から、このチュートリアルでは「スコアを記録する」というユースケースを実現することを目標にします。
とくに、「ゲームを進める」ことと「ボウリングのスコアを計算する」ことについて、モデルを使って表現し、そのモデルからプログラムを得るように努めます。

スコアのつけ方については、これまで検討してきた「クラッシックスコアリング」を対象としましょう。
「カレントフレームスコアリング」に比べて、フレームの間に依存関係がある分、スコア計算がより複雑になっています。
