ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_requirement_anaylysis]]
== スコアシートのデータ構造を調べる

[.lead]
ボウリングスコアはどのような構造になっているでしょうか。
また、スコアをつける手順に従うとき、スコアにはどのような状態があるのでしょうか。


[NOTE]
--
このチュートリアルでは、クラッシックスコアリング <<classic_scoring>> の場合について考えることにします。
--


=== スコアシートの構造をオブジェクト図で表す

スコアシートの例を参照しながら、スコアシートの構造を検討しましょう。

==== スコアシートの例


ゲーム中のスコアシートの例を <<scoresheet01>> に示します。
この例では、2人でプレーしています。
いまは、2ゲーム目のプレー中で、1人目の6フレーム目の第1投目までゲームが進んでいます。
また、彼らは1フレームずつ交代で投球していることがわかります。
もし、彼らがもう1ゲーム分プレーする場合には、このスコアの下にもう一度2人分のスコアが追加されるでしょう。

[[scoresheet01]]
.スコアシートの例
image::scoresheet02.png[{full-width}]

[NOTE]
--
ボウリングでは、「ゲーム」ということばは、各自が10フレーム分プレーした結果を指す場合と、複数名で10フレーム分プレーしたひと組の結果を指す場合があるようです。
これらを呼び分ける方法わからなかったので、このチュートリアルでは、前者を「スコア」、後者を「ゲーム」と呼ぶことにします。

実際のボウリング競技においてこれらを呼び分ける名前等をご存知の方は、そのを呼び分け方を使うとよいでしょう。
--

スコアシートを観察してわかることを <<scoresheet02>> にまとめました。

[[scoresheet02]]
.スコアシートを観察してわかること
[example]
--
* スコアシートには、プレー開始日時が記載されている。
* スコアシートには、プレーヤー名とその人の10フレーム分の投球を記録する欄がある。
** これをスコアと呼ぶことにする。
* ひとつのゲームの進行中は、1フレームごとにプレーヤーが交代して投球する。
** この方式は、ベーカー方式と呼ばれている。
* スコアシートには、複数人のスコアが記録されている。
** 同時に進行している複数名のスコアのまとまりをゲームと呼ぶことにする。
* プレーヤーの組を単位として複数回ゲームをプレーできる。
--

<<scoresheet02>> にまとめたことを元に、スコアシートの構成要素や構成要素の間の関係をモデル図で表してみましょう。

==== プロジェクトに設計モデルを追加する

まず、 {astah} で作成したプロジェクトに設計モデルを追加しましょう。


[TIP]
--
ここでは、設計モデルは、対象とする業務やサービスに必要となる構成要素やその関係を「構造のモデル」（静的モデル）として表したものとします。
また、業務やサービスを実現するために必要となる構成要素の動作を「振舞いのモデル」（動的モデル）として表すことも含むものとします。
設計に関わる構成要素は、対象とする業務やサービスを分析して得られることもあれば、開発に採用する資源や方式から得られることもあります。
--

[[add_design_model]]
.プロジェクトに設計モデルを追加する
[example]
--
. プロジェクトにモデルを追加する。
** 構造ツリー上で、プロジェクトを選択する。
** 右クリックしてポップアップメニューを開き、「モデルの追加＞モデル」を選択する（ <<add_design_model01>> ）。

[[add_design_model01]]
.プロジェクトにモデルを追加した
image::GSW-20220206-132000.png[{three-quarters-width}]


[start=2]
. 追加したモデルに名前をつける。
** 構造ツリー上で、追加したモデルを選択した状態で、プロパティの「ベース」タブを選択する。
** 「名前」を編集して「設計モデル」とする（ <<add_design_model02>> ）。
** 入力が確定すると、構造ツリーの表示にも反映される。

[[add_design_model02]]
.モデルに設計用のモデルとして名前をつけた
image::GSW-20220206-132154.png[{three-quarters-width}]
--

==== 設計モデルにオブジェクト図を追加する

「オブジェクト図（インスタンス図と呼ぶこともあります）」を使ってスコアシートに登場するオブジェクトを表してみましょう。
{astah} では、オブジェクト図を作成するときは「クラス図」を使いますので、クラス図を追加しましょう。


.設計モデルにオブジェクト図を追加する
[example]
--
. モデルにクラス図を追加する
* 構造ツリーから設計モデルを選択し、右クリックしてポップアップメニューを開く（ <<object00>> ）。
* 「図の追加＞クラス図」でクラス図が追加される。

[[object00]]
.モデルにクラス図を追加する
image::GSW-20220206-132218.png[{three-quarters-width}]

[start=2]
. オブジェクト図に名前をつける
* 追加したクラス図のプロパティの「ベース」タブを開く。
* 名前を編集して「ゲームスコアのオブジェクト図」とする（  <<object01>> ）。
* ダイアグラムエディタのタイトルやタブにも反映される。

[[object01]]
.図の名前を「ゲームスコアのオブジェクト図」にする
image::GSW-20220206-133044.png[{three-quarters-width}]
--

==== オブジェクト図にスコアシートを追加する

<<scoresheet01>> や <<scoresheet02>> を参照しながら、スコアシートに記載されている要素をオブジェクト図に追加してみましょう。

まず、「スコアシート」オブジェクトを追加します。

[[add_scoresheet01]]
.スコアシートを表すオブジェクトを追加する
[example]
--
. パレットから「インスタンス仕様」を選択して、図に配置する（ <<add_instance01>> ）。
** 「インスタンス仕様0」という名前のオブジェクトが配置される（末尾の数字は作るたびに変わる）。

[[add_instance01]]
.インスタンス仕様を追加する
image::GSW-20220206-133142.png[{three-quarters-width}]

[start=2]
. 追加したオブジェクトの名前をスコアシートを表す固有の名前に変える。
** オブジェクトを選択した状態でプロパティから編集する（ <<obj_scoresheet01>> ）。
** <<scoresheet01>> のスコアシートを示す固有の名前をつける。ここでは「scoresheet01」とした。
** 名前の入力が確定すると、オブジェクトの名前にも反映される。

[[obj_scoresheet01]]
.名前を「scoresheet01」に変更する
image::GSW-20220206-133218.png[{three-quarters-width}]

TIP: 個々のオブジェクトを識別するためにつける名前のことを、オブジェクト名（またはインスタンス名）と呼びます。

--
==== スコアシートオブジェクトにクラスを割り当てる

追加したオブジェクトは、どのようなクラスのオブジェクトなのか定まっていません。
それが分かるようクラスを定義して割り当てておきましょう。

[[add_class_and_apply]]
.クラスを追加してオブジェクトに割り当てる
[example]
--
. オブジェクト「scoresheet01」を選択した状態で、プロパティから「新規作成」ボタンをクリックする（ <<class_def_dialog00>> ）。

[[class_def_dialog00]]
.オブジェクトを選択してクラスを「新規作成」する
image::GSW-20220206-133232.png[{three-quarters-width}]

[start=2]
. クラス「ScoreSheet」を定義する。
** クラスを定義するダイアログが表示される（ <<class_def_dialog01>> ）。
** 「ベース」タブを選択し、名前に「ScoreSheet」を入力する。

[[class_def_dialog01]]
.クラス「ScoreSheet」を定義する
image::GSW-20220206-133247.png[{half-width}]

[start=3]
. スコアシートにはプレー開始日時があるので、これを属性に追加する。
** 「属性」タブを選択する。
** 「＋」ボタンを押すと属性が追加されるので、名前に「play_date」を入力する（ <<add_attr_play_time>> ）。


[[add_attr_play_time]]
.属性「play_date」を追加する
image::GSW-20220206-133548.png[{half-width}]

[start=4]
. 属性「play_date」の型を定義する。
** 「型」欄を編集状態にして「Time」を入力すると、「型になるTimeを新規作成しますか？」というメッセージのダイアログが表示される（ <<dialog_add_class_time>> ）。
** 「はい」をクリックしてダイアログを閉じる。
** クラス「Time」が作成され、構造ツリーにも追加される（ <<class_time_added>> ）。

NOTE: 「Time」クラスは、Rubyのライブラリで、日付と時刻を操作するためのクラスです。

[[dialog_add_class_time]]
.クラス「Time」の追加を促すダイアログ
image::GSW-20220206-173841.png[{half-width}]


[[class_time_added]]
.クラス「Time」が追加された
image::GSW-20220206-172618.png[{half-width}]

[start=5]
. オブジェクト図や構造ツリーを確認する（ <<instance03>> ）。
** 「閉じる」をクリックして、クラス定義のダイアログを閉じる。
** オブジェクトの表示が「scoresheet01 : ScoreSheet」に変わっている。
** 属性「play_date」の属性値を保持する欄（スロッと呼ぶ）も追加されている。
** 構造ツリーにもTimeクラスが追加されている。

[[instance03]]
.オブジェクトにクラスやスロットが割当てられた
image::GSW-20220206-133959.png[{full-width}]

[start=6]
. 追加したスロットに属性値を設定する（ <<instance04>> ）。
** オブジェクト「scoresheet01」を選択して、プロパティから「ベース」タブを開く。
** 属性「play_date」の値に日時、たとえば「2022/02/04 16:18」などと入力する。

[[instance04]]
.オブジェクトのスロットに属性値が追加された
image::GSW-20220206-181040.png[{full-width}]

--


==== オブジェクト図にゲームを追加する

次に、「スコアシート」を追加したのと同じ手順で「ゲーム」オブジェクトを追加します。
<<scoresheet01>> の場合ゲームが2組あるので、ゲームのオブジェクトを「game01」、「game02」としましょう。
クラス名は「Game」としましょう。

[[add_game00]]
.ゲームを表すオブジェクトを追加する
[example]
--
. 最初の（1組目の）ゲームを追加する。
**. パレットから「インスタンス仕様」を選択して図に配置する。
** オブジェクト名を「game01」とする。
** クラスを追加して「Game」とする（ <<add_game01>> ）。

[[add_game01]]
.ゲームを表すオブジェクト「game01」とクラス「Game」を追加した
image::GSW-20220207-000330.png[{full-width}]

[start=2]
. 次の（2組目の）ゲームを追加する。
** 同様の手順で「game02」を追加する。
** プロパティから既存のクラスをプルダウンし、「Game」クラスを選択する（ <<add_game02>> ）。

[[add_game02]]
.ゲームを表すオブジェクトを追加し、既存のクラスを割当てた
image::GSW-20220207-001520.png[{full-width}]
--

==== オブジェクト図にスコアを追加する

こんどは、プレーヤーひとり分のスコアを記録しているスコア部分を追加しましょう。
<<scoresheet01>> の場合、スコアは4つあります。

このチュートリアルでは、プレーヤー名はスコアの属性と考えることにしておきます。
（もちろん、プレーヤーを独立したクラスと考え、複数のスコアとを関連づけた方がもっとよいでしょう）


[[add_screr00]]
.それぞれのプレーヤーのスコアを表すオブジェクトを追加する
[example]
--
. パレットから「インスタンス仕様」を選択して図に配置して「score01」とする。
. 「Score」クラスを追加して、「score01」に割当てる（ <<add_score01>> ）。

[[add_score01]]
.スコアを表すオブジェクト「score01」を追加した
image::GSW-20220207-012006.png[{full-width}]

[start=3]
. 「Score」クラスに属性「player」を追加し、「String」クラスを追加して割当てる（ <<add_string_class>> ）。

[[add_string_class]]
.属性「Player」を追加し、クラス「String」を追加して割当てる。
image::GSW-20220207-011349.png[{half-width}]


[start=4]
. 「score01」のスロット「player」の値に「くぼあき」を設定する（ <<add_score02>> ）。

[[add_score02]]
.「player」のスロットの値にプレーヤー名を設定した
image::GSW-20220207-014911.png[{full-width}]


. ほかのスコアのオブジェクトも作成する（ <<add_score03>> ）

[[add_score03]]
.残りのスコアのオブジェクトを作成した
image::GSW-20220207-024336.png[{full-width}]

--

==== オブジェクト図にフレームを追加する

次に、各スコアに記載されているフレームを追加しましょう。
ですが、フレームのオブジェクトの数が多いので、この場で作成してみるのは一部だけにします。

[[add_frame00]]
.それぞれのスコアのフレームを表すオブジェクトを追加する
[example]
--
. パレットから「インスタンス仕様」を選択して図に配置して「frame0101」とする。
. 「Frame」クラスを追加して、「frame010」に割当てる（ <<add_frame01>> ）。
. 「Frame」クラスの属性に「frame_no」、「first」、「second」、「spare_bonus」、「strike_bonus」、「total」を追加する。

[[add_frame01]]
.フレームを表すオブジェクト「frame01011」を追加した
image::GSW-20220207-030417.png[{full-width}]

. オブジェクト「frame0101」の各スロットに値を設定する（ <<add_frame02>> ）。
** 1組目のゲームの「くぼあき」さんの第1フレームは、1投目7ピン、2投目ミス（0ピン）。
** 第1フレームのトータルは7ピン。ボーナスはなし。

[[add_frame02]]
.オブジェクト「frame01011」の各スロットの値を設定した
image::GSW-20220207-031606.png[{full-width}]

. 同様にして、ほかのフレームのオブジェクトも作成する（ <<add_frame03>> ）。

[[add_frame03]]
.残りのフレームのオブジェクトを作成した（一部だけ）
image::GSW-20220207-042412.png[{full-width}]

--


==== オブジェクトのつながりを整理する

オブジェクト図に、スコアシート、ゲーム、スコアのオブジェクトが追加できました。
<<scoresheet01>> を見ながら、これらはの間にはどのようなつながりがあるか考えてみましょう。

.オブジェクト同士のつながりを考える
[example]
--
* スコアシートは複数のゲームを記録できるので、スコアシートとゲームにはつながりがありそうです。
* ゲームでは、複数のプレーヤーのスコアを記録するので、ゲームとスコアにはつながりがありそうです。
* スコアにはフレームごとのピン数等を記録するので、スコアとフレームにはつながりがありそうです。
--

オブジェクトの間のつながりを表すには「リンク」を引きます。
つながりがありそうなオブジェクト同士にリンクを引いてみましょう。

まず、スコアシートとゲームの間にリンクを引きましょう。

[[add_link00]]
.「scoresheet01」から「game01」へリンクを引く
[example]
--
. パレットから「リンク」を選択して、「scoresheet01」の内部へマウスカーソルを移動し、青枠が表示されるのを待つ（ <<add_link01>> ）。

[[add_link01]]
.リンクの引き始めのオブジェクトで青枠を表示させる
image::GSW-20220207-054611.png[{full-width}]

[start=2]
. 青枠が表示されたら、マウスのボタンを押したまま「game01」の内部へマウスカーソルを移動する（ <<add_link02>> ）。

[[add_link02]]
.青枠が表示されたらマウスのボタンを押したままマウスカーソルをドラッグする
image::GSW-20220207-061048.png[{full-width}]

[start=3]
. 「game01」にも青枠が表示されたら、マウスのボタンを離すとリンクが引かれる（ <<add_link03>> ）。

[[add_link03]]
.リンク先のオブジェクトにも青枠が表示されたらマウスのボタンを離す
image::GSW-20220207-061016.png[{full-width}]

[start=4]
. 「game02」へも同様の手順でリンクを引く。
--

同様の手順で、ほかのオブジェクトの間にもリンクを引きます。


[[add_link04]]
.ほかのオブジェクトの間にもリンクを引く
[example]
--
. ゲームからスコアへリンクを引く（ <<add_link05>> ）。
** 1ゲーム目のスコアは、1つ目のゲームにリンクを引く。
** 2ゲーム目のスコアは、1つ目のゲームにリンクを引く。

[[add_link05]]
.ゲームからスコアへリンクを引く
image::GSW-20220207-063524.png[{full-width}]

[satrt=2]
. スコアからフレームへもリンクを引く（ <<add_link06>> ）。

[[add_link06]]
.残りのつながりについてリンクを引く
image::GSW-20220207-065042.png[{full-width}]

--

これで、 <<scoresheet01>> の要素を反映したオブジェクト図が作成できました。

=== スコアシートの構造をクラス図で表す

作成したオブジェクト図 <<add_link06>> を元に、ゲームスコアのクラス図を作成してみましょう。

==== スコアシートのクラス図を追加する


まず、「ゲームスコアのクラス図」を追加します。

[[class00]]
.ゲームスコアのクラス図を追加する
[example]
--
* 構造ツリーで、「設計モデル」でポップアップメニューを開き、「図の追加＞クラス図」でモデルにクラス図を追加する（ <<class01>> ）。

[[class01]]
.モデルにクラス図を追加する
image::GSW-20220207-065747.png[{half-width}]

[start=2]
. 追加した図を「ゲームスコアのクラス図」とする（ <<class02>> ）。

[[class02]]
.追加した図を「ゲームスコアのクラス図」とした
image::GSW-20220207-065801.png[{half-width}]
--
==== クラス図にクラスを追加する

「構造ツリー」をみると、オブジェクト図を作成したとき登録した「ScoreSheet」クラスや「Game」クラスなどが見つかります。
これらを1つずつドラッグ＆ドロップして、クラス図に追加します（ <<class03>>  ）。

[[class03]]
.既存のクラスを構造ツリーからクラス図に追加する
image::GSW-20220207-070838.png[{full-width}]

==== クラス間の関連を追加する（１）

作成したオブジェクト図（ <<add_link05>> ）に記載されているリンクを参照して、リンクでつながっているオブジェクトが属するクラスの間に関連を引きます。

まず、「ScoreSheet」クラスから「Game」クラスへ向かって関連を引きましょう。

[[add_relation00]]
.スコアシートとゲームの間に関連を追加する
[example]
--
. 「ScoreSheet」クラスから「Game」クラスへ関連を引く（ <<class04>> ）。
** パレットから矢印付きの関連を選択する。
** 「ScoreSheet」クラスから「Game」クラスへ向かって関連を引く

[[class04]]
.「ScoreSheet」クラスから「Game」クラスへ関連を引いた
image::GSW-20220207-082944.png[{three-quarters-width}]

[start=2]
. スコアシートには1ゲーム以上の複数のゲームを記録できる。このことを多重度で表す。
** <<class04>> で引いた関連を選択した状態で、プロパティからターゲットが「Game」の関連端のタブを開く。
** 「多重度」を「1..*」に設定する（ <<class05>> ）。

[[class05]]
.「ScoreSheet」からみた「Game」の多重度を「 1..* 」に設定した
image::GSW-20220207-083800.png[{half-width}]

[start=3]
. スコアシートがゲームを参照するときに使う名前を決めるために、関連端名を設定する。
** <<class04>> で引いた関連を選択した状態で、プロパティからターゲットが「Game」の関連端のタブを開く。
** ゲームを複数回記録できることを反映して、「名前」を「games」に設定する（ <<class06>> ）。

[[class06]]
.「ScoreSheet」からみた「Game」の関連端名を「games」に設定した
image::GSW-20220207-084200.png[{half-width}]

[start=4]
. スコアシートには、プレーヤーがゲームをやるたびにゲームを追加できる（スコアシートはゲームを集約しているが、互いのライフサイクルが異なる）ことを示すために、集約を設定する。
** <<class04>> で引いた関連を選択した状態で、プロパティからターゲットが「ScoreSheet」の関連端のタブを開く。
** 「集約」のプルダウンメニューから「aggregate」を選択する（ <<class07>>）。


[[class07]]
.「ScoreSheet」が「Game」を集約していることを示した
image::GSW-20220207-085154.png[{half-width}]

[start=5]
. 「ScoreSheet」から「Game」への関連が引けた（ <<class08>> )。

[[class08]]
.「ScoreSheet」から「Game」への関連が引けた
image::GSW-20220207-090055.png[{three-quarters-width}]
--

==== クラス間の関連を追加する（２）

こんどは、「Game」クラスから「Score」クラスへ向かって関連を引きましょう。
1組のゲームには、複数プレーヤーのスコアが記録できます。
つまり、ここにはスコアシートとゲームの間と同じような関連が引けそうですね。

[[add_relation02]]
.ゲームとスコアの間に関連を追加する
[example]
--
. 「Game」クラスから「Score」クラスへ関連を引く。
. 「Score」クラス側の関連の多重度を「1..*」に設定する。
. 「Score」クラス側の関連端には関連端名として「scores」を設定する（複数のスコアが記録できることを反映した）。
. 「Game」クラス側の「集約」のプルダウンメニューから「aggregate」を選択する（ <<add_relation03>> ）。

[[add_relation03]]
.ゲームとスコアの間に関連を引いた
image::GSW-20220207-094813.png[{full-width}]
--

そして、最後に、「Score」クラスから「Frame」クラスへ向かって関連を引きましょう。
このチュートリアルでは、スコアのオブジェクトを用意したときは、常に10フレーム分のフレームのオブジェクトも一緒に用意することとします。
この場合、フレームとスコアは同時に作成されるので（ライフサイクルが同じなので）、集約の設定もコンポジションにしておきます。


[[add_relation04]]
.スコアとフレームの間に関連を追加する
[example]
--
. 「Score」クラスから「Frame」クラスへ関連を引く。
. 「Frame」クラス側の関連端の多重度を「10」に設定する。
. 「Frame」クラス側の関連端には関連端名として「frames」を設定する（複数のフレームが記録できることを反映した）。
. 「Score」クラス側の関連端の集約を変更する。
** 集約のプルダウンメニューの中から「composite」を選択する（ <<add_relation05>> ）。
** 「Score」クラス側の関連端の表示が、黒塗りのダイアモンド（コンポジションのシンボル）に変わる。

[[add_relation05]]
.スコアとフレームの間に関連を引いた
image::GSW-20220207-122557.png[{full-width}]
--

これで、いったん、ボウリングのゲームスコアを表した構造のモデルができました。

==== まとめ

ボウリングのゲームスコアを記録するスコアシートの構造を検討しました。

.スコアシートの構造のモデルを作成した手順
[example]
--
. スコアシートを観察して、どのような要素で構成されているか洗い出した。
. スコアシートの実例をそのまま使ってオブジェクト図で表した。
. オブジェクト図の要素や要素間のつながりを観察して、クラス図を作成した。
--

ここで作成したクラス図には、検討の余地が残っています。
たとえば、いずれのクラスにも操作が定義できていません。
これは、プレーするのに従ってスコアをつけるときの動作（振舞い）を検討していないからです。
また、属性や関連についても、動作を検討する中で追加や修正が必要になる場合があるでしょう。

== スコアの状態を調べる

[.lead]
スコアをつける手順に従うとき、スコアにはどのような状態があるのでしょうか。

=== フレームの状態について検討する

<<scoresheet01>> を見ると、ゲームの進行状況によってフレームが提示する情報には <<frama_differences>> のような違いがあります。

[[frama_differences]]
.フレームの提示する情報の違い
[example]
--
* まだプレーしていないフレーム
* 1投目の投球を待っているフレーム
* 2投目の投球を待っているフレーム
* 2投目が投球されて獲得ピン数が確定したフレーム
* ストライクのボーナスが確定しないフレーム
* スペアのボーナスが確定しないフレーム
* スペアまたはストライクのボーナスが確定したフレーム
--

==== まだプレーしていないフレーム

まだプレーしてないフレームは、フレームの最初の状態です（ <<reserved01>> ）。
このフレームは、ピン数の入力を待っていません。

[[reserved01]]
.まだプレーしていないフレーム
image::reserved.png[{three-quarters-width}]

==== 1投目の投球を待っているフレーム

現在プレー中のフレームで、まだ1投目が投球されていない状態のフレームです（ <<before_1st01>> ）。
次にピン数を受け取ると、このフレームの1投目に記録されます。

[[before_1st01]]
.1投目の投球を待っているフレーム
image::before_1st.png[{three-quarters-width}]

==== 2投目の投球を待っているフレーム

現在プレー中のフレームで、1投目がストライクでなかったときに2投目を待っている状態のフレームです（ <<before_2nd01>> ）。
次にピン数を受け取ると、このフレームの2投目に記録されます。

[[before_2nd01]]
.2投目の投球を待っているフレーム
image::before_2nd.png[{three-quarters-width}]


==== スペアのボーナスの確定待ちのフレーム

現在プレー中のフレームの前のフレームがスペアで、現在のフレームが1投目の投球を待っているとき、前のフレームはスペアボーナスの確定待ちの状態です（ <<pending_spare01>> ）。
次にピン数を受け取ると、このフレームの1投目に記録されるとともに、前のフレームのスペアボーナスが確定します。

[[pending_spare01]]
.スペアのボーナスの確定待ちのフレーム
image::pending_spare.png[{three-quarters-width}]

==== ストライクのボーナスの確定待ちのフレーム

ストライクボーナスの確定待ちには2通りの場合があります。

まず、現在プレー中のフレームの前のフレームがストライクで、現在のフレームが2投目の投球を待っているときです。
このとき、前のフレームはストライクボーナスの確定待ちの状態です（ <<pending_strike01>> ）。
次にピン数を受け取ると、このフレームの2投目に記録されるとともに、前のフレームのストライクボーナスが確定します。

[[pending_strike01]]
.ストライクのボーナスの確定待ちのフレーム（次がストライクでない）
image::pending_strike.png[{three-quarters-width}]

いまひとつは、現在プレー中のフレームが1投目の投球を待っていて、前のフレームと前の前のフレームがともにストライクであったとき（ダブルのとき）ときです。
このとき、前の前のフレームはストライクボーナスの確定待ちの状態です（ <<pending_double01>> ）。
次にピン数を受け取ると、このフレームの1投目に記録されるとともに、前の前のフレームのストライクボーナスが確定します。

[[pending_double01]]
.ストライクのボーナスの確定待ちのフレーム（次がストライク）
image::pending_double.png[{three-quarters-width}]


==== 獲得ピン数とボーナスが確定したフレーム

現在のフレームがスペアやストライクにならなかったとき、そのフレームはボーナスの確定待ちにならず、この段階でそのフレームのトータル（ボーナスなしの獲得ピン数）が確定します。

スペアボーナスの確定待ち、またはストライクボーナスの確定待ちのフレームは、後のフレームの投球によってボーナスが確定すると、フレームのトータルが確定します。
このとき、確定待ちのフレームでは、そのフレームの獲得ピン数と確定したボーナスの合計がそのフレームのトータルになります。

フレームのトータルが求められると、それ以前のフレームまでの「延べのトータル」にそのフレームのトータルを加算して、延べのトータルを更新します。そして、更新した延べのトータルがフレームの下部に記録されます（ <<fixed01>> ）。

[[fixed01]]
.2投目を投球して、ピン数が確定したフレーム（のべのトータルが求められている）
image::fixed01.png[{three-quarters-width}]


=== フレームの状態をステートマシン図で表す

フレームの状態を検討した結果、フレームはいくつかの状態を持つことがわかりました。
フレームが表示できる情報も、状態によって異なることがわかりました。
このことを、図に表してみましょう。
状態とその変化（状態遷移と呼びます）を表すには、ステートマシン図を使います。

==== フレームクラスにステートマシン図を追加する

「Frame」クラスの状態を表す図を描きたいので、「Frame」クラスに図を追加しましょう。

[[add_frame_stm00]]
.フレームクラスにステートマシン図を追加する
[example]
--
. 「Frame」クラスにステートマシン図を追加する
** 構造ツリーから「Frame」クラスを選択し、右クリックしてポップアップメニューを表示を開く（ <<add_frame_stm01>> ）。
** 「図の追加＞ステートマシン図」でステートマシン図が追加される。

[[add_frame_stm01]]
.フレームクラスにステートマシン図を追加する
image::GSW-20220207-154421.png[{three-quarters-width}]

[start=2]
. ステートマシン図に名前をつける
** 追加したステートマシン図のプロパティの「ベース」を開く。
** 名前を編集して「Frameクラスのステートマシン図」とする（ <<add_frame_stm02>> ）。
** ダイアグラムエディタのタイトルやタブにも反映される。


[[add_frame_stm02]]
.ステートマシン図に名前をつける
image::GSW-20220207-155242.png[{full-width}]

--

=== サービスフレームの扱いについて検討する

「クラッシックスコアリング」の場合、第10フレームが他のフレームとは異なっています。
サービスフレームという考え方があり、ストライクやスペアの場合に追加で投球できます。

このサービスフレームの扱い方にについて整理しておきましょう。

==== 第10フレームがストライクもスペアもない場合

第10フレームがストライクでもスペアもない場合、サービスフレームは提供されません。
第9フレームまでの通常のフレームと同様、1投目と2投目を記録するだけです（ <<ten_no_service>>  ）。


[[ten_no_service]]
.第10フレームがストライクもスペアもない場合
image::ten_no_service_combo.png[{three-quarters-width}]

==== 第10フレームがスペアの場合

第10フレームの2投目でスペアになった場合、1投目と2投目を通常のフレームと同様に記録したのち、もう1投追加されます。
これを、第10フレームに加えて、第11フレームの1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_spare_service>> 」のように構成します。

[[ten_spare_service]]
.第10フレームがスペアの場合（第11フレームの2投目はない）
image::ten_spare_combo.png[{three-quarters-width}]

スコアをこのように構成しておくと、第10フレームの場合も、通常フレームの組み合わせによってボーナスが計算できます。
ゲーム終了時の第10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


==== 第10フレームの1投目がストライクの場合

第10フレームの1投目がストライクの場合、第10フレームをストライクとした上で、もう2投追加されます。
これを、第10フレームに加えて、第11フレームの1投目と2投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_one_strike_service>> 」のように構成します。
だたし、第11フレームの1投目がストライクの場合は、同じ2投追加でも次の「2投目もストライクの場合」の考え方を使います。

[[ten_one_strike_service]]
.第10フレームの1投目がストライクの場合
image::ten_one_strike_combo.png[{three-quarters-width}]

スコアをこのように構成しておくと、第10フレームの場合も、通常フレームの組み合わせによってボーナスが計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。

==== 第10フレームの2投目もストライクの場合

第10フレームの2投目もストライクの場合、第10フレーム、第11フレームをストライクとした上で、もう1投追加されます。
これを、第10フレーム、第11フレームに加えて、第12フレーム目の1投目が追加されたとみなします。
つまり、ゲームスコアのデータを「 <<ten_two_strike_service>> 」のように構成します。
このように構成すれば、通常のフレームでダブルをとったときの計算方法（ストライクが続いたときはさらに次のフレームの1投目が2投目として加算される）のままで第10フレームのボーナスが計算できます。

[[ten_two_strike_service]]
.第10フレームの2投目もストライクの場合
image::ten_two_strike_combo.png[{three-quarters-width}]

スコアをこのように構成しておくと、第10フレームの場合も、通常フレームの組み合わせによってボーナスが計算できます。
ゲーム終了時の10フレームのスコア（ピン数に以後の投球によるボーナスを加えたスコア）を取得するとそれがゲームのスコアになります。


==== クラス図に検討結果を反映する

第10フレームの場合にもサービスフレームのために追加のフレームを用意することで、通常フレームと同じようにピン数やボーナスを扱えるようになりました。

クラス図にこの結果を反映しましょう。


[[add_service_frame]]
.クラス図にサービスフレームを検討結果を反映する
[example]
--
. 「Frame」クラス側の関連端の多重度を「10」から「12」に変更する。
. 関連にノートをつけて説明をつけておく。
** パレットからノートを選択し、クラス図に追加する。
** ノートに「Frame側の多重度は、サービスフレーム用に必要なフレーム分だけ追加してある」という説明を追加する。
. ノートから関連の線に向かってアンカーを引く。
** パレットからノートのアンカーを選択し、ノートにマウスカーソルを移動して青枠が表示されるのを待つ。
** マウスのボタンを押したまま、マウスカーソルをドラッグし、関連の線に近づけ青枠が表示されるのを待つ。


TIP: ノート内の文章を編集するときは、ノートを選択した状態でプロパティを使って編集すると、改行の入力が容易になります。

--


=== ゲームの進行について検討する



