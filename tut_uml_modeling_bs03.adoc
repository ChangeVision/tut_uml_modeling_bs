ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_model_to_code_design]]
[%nonfacing]
== モデルとコードの対応づけ

[.lead]
プログラムがどのように動作するのか検討するときには、振る舞いのモデルを使います。
振る舞いのモデルを作成する前に、構造のモデルと振る舞いのモデルがどのようなコードとして実現されるのかについて、このチュートリアルで用いる方式を決めておきましょう。
このことを「モデルとコードの対応づけ」と呼ぶことにします。

TIP: このような対応づけを「モデル変換ルール」と呼ぶこともあります。また、開発プロセスのなかでこの対応づけを検討する工程を「方式設計」と呼ぶ人もいます。

モデルとコードの対応づけを決めてそれを前提にして設計する（モデルを作る）ことは、実装に依存する情報と依存しない情報の分離を促します。
また、このような考え方は、実装に依存しないモデルを作る上でとても重要で、実務的なモデルを作成する際にも大いに役立ちます。


=== 対応づけ検討用モデルの作成


このチュートリアルでは実装にRubyを使うことにしました。
サンプルモデルとサンプルモデルに対応するRubyプログラムを作ってみることで、対応づけの方式の基本的な考え方を決めておこうというわけです。

[NOTE]
--
この章で検討したいことは、ボウリングのスコアに関するモデルの問題領域とは直接の関係はありません。
こういった別の領域の問題を、これまで検討していたボウリングのスコアに関する問題領域と、ここで検討したいことが混在してしまい、說明も受け取り手も混乱してしまうでしょう。
そんなわけで、別の問題として分けて検討するために、この章を用意してあります。

もし、この章の役割がピンとこない、実装についての議論にはあまり関心がないのであれば、最初はこの章を読み飛ばしてみてもかまいません。
しかし、後の章へ進むと、実装する人がモデルを使う際には、モデルとコードを対応づける必要があり、ここで実装方式を決めておかなければ、実装者がそのことについて考える必要がある（特定の実装者に依存しないよう設計しておくべきことを実装する各人に委ねてしまっている）ことに気づくでしょう。
そのときは、この章に戻って、どうして実装方式の設計が必要なのか考えてもらえたらと思います。
--

==== 対応づけ検討用プロジェクトを用意する

「モデルとコードの対応づけ」の検討用に {astah} で別のプロジェクトを作成しましょう。

===== 対応づけ検討用プロジェクトを作成する

* {astah} で新規プロジェクトを作成する。
* 作成したプロジェクトをいったん保存する。
* モデルファイルの名前は「stm_sample.asta」とする。


[[add_stm_sample_class_diag]]
===== 検討用プロジェクトにクラス図を追加する

プロジェクトが保存できたら、プロジェクトにクラス図を追加しましょう。

* 構造ツリーで、プロジェクト名をクリックしてポップアップメニューを開く。
* 「図の追加＞クラス図」でクラス図を追加する。
* プロパティーから、クラス図の名前を「クラス図」に変更する。

[[add_stm_sample00]]
.対応づけの説明に使うプロジェクトにクラス図を追加した
image::GSW-20220213-005309.png[{half-width}]

[[add_sample_class00]]
===== クラス図に「Sample」クラスを追加する

対応づけの説明用に、簡単なクラス「Sample」の定義から始めましょう。
このクラスは、操作「Play」と属性「attr_a」「attr_b」を持つクラスとします。
これをUMLのクラスとして表してみましょう。

* パレットからクラスを選択し、クラス図に追加する。
* クラス名を「Sample」にする（ <<sample_class01>> ）。
* クラスに操作「play」を追加する。
* クラスに属性「attr_a」「attr_b」を追加する。

[[sample_class01]]
.クラス図に「Sample」クラスを追加した
image::GSW-20220212-220754.png[{three-quarters-width}]

===== Sampleクラスの最初のサンプルコード

対応づけルールの1つ目として、 <<sample_class01>> を表したRubyのコードは <<ruby_sample01>> のように書きたいと決めることにします。

[[ruby_sample01]]
.【Ruby】「Sample」クラスを表すRubyのコード
[source,ruby]
----
class Sample # <1>
  def initialize # <2>
    @attr_a = true # <3>
    @attr_b = true # <3>
  end

  def play # <4>
  end
end
----
<1> クラス「Sample」の定義の始まり
<2> 初期化メソッド（コンストラクタにあたるメソッド）
<3> このクラスのインスタンス変数
<4> メソッド「Play」の定義の始まり

==== クラスにステートマシン図を追加する

このサンプルにおいては、いま追加した操作「play」が、「Sample」クラスの振る舞いを提供しているとします。
しかし、クラス図に描いた「Sample」クラスに操作「play」を追加しただけでは、その処理内容はわかりません。
どこかに「play」の処理内容を表した図が必要です。

そこで、「Sample」クラスに対して、操作「play」の振る舞いを表すステートマシン図を追加します。
ここで、図を追加する対象を「Sample」クラスにしているのは、このステートマシン図が「Sample」クラスの振る舞いのモデル図であるとわかるようにするためです。

[[add_stm_sample01]]
===== クラスにステートマシン図を追加する

「Sample」クラスにステートマシン図を追加します。

* 構造ツリーから「Sample」クラスを選択する。
* 右クリックしてポップアップメニューを表示する（ <<add_stm_sample02>> ）。
* 「図の追加＞ステートマシン図」を選択すると、ステートマシン図が追加される。

[[add_stm_sample02]]
.「Sample」クラスにステートマシン図を追加する
image::GSW-20220213-020944.png[{three-quarters-width}]

* プロパティーから図の名前を編集し、「Sampleのplayのステートマシン図」とする（ <<add_stm_sample03>> ）。
* ダイアグラムエディタのタイトルやタブにも図の名前が反映される。

[[add_stm_sample03]]
.追加したステートマシン図に名前をつける
image::GSW-20220213-013034.png[{three-quarters-width}]

.【参考】ステートマシン図を学ぶチュートリアル
****
ここでは、モデルとコードの対応づけを説明するために、振る舞いのモデルの一種であるステートマシン図を作成しています。
ステートマシン図を使って振る舞いを設計する方法については、次のチュートリアルも参考にしてみてください。

ステートマシン図 & 状態遷移表チュートリアル:: `https://www.changevision.co/tutorial-statemachine-japanese.html`
****

[NOTE]
--
<<add_stm_sample02>> では、Sampleクラスの振舞いを表すステートマシン図とわかるようにと考えて、クラスに対してステートマシン図を割り当てました。
この他、 {astah} では、メソッドに対してステートマシン図を割り当てることもできます。
任意のメソッドの処理を示すステートマシン図の割当てとしては、後者のほうが好ましいでしょう。
ここでは、クラスの振舞いということを意識して、クラス図に割当ててみています。
どちらの方法を使うにしても、クラスの振舞いを担当するメソッドを対応づけすることは必要になるでしょう。
--
==== ステートマシン図に状態を追加する

次に、追加したステートマシン図に、状態を追加します。

.ステートマシン図に状態を追加する
. パレットから「状態」を選択し、ステートマシン図に状態を追加する。
** 追加した状態の状態名は「状態0」（数字は追加の都度変わる）となっている（ <<add_stm_sample04>> ）。

[[add_stm_sample04]]
.新しい状態を追加した
image::GSW-20220213-093229.png[{three-quarters-width}]

[start=2]
. 「状態0」を選択し、プロパティーの「ベース」タブの「名前」を編集して、状態の名前を「ST0」にする（ <<add_stm_sample05>> ）。
** 状態「ST0」は、このサンプルの例示用に使う状態名の1つ。

[[add_stm_sample05]]
.新しい状態に状態名をつけた
image::GSW-20220213-104448.png[{three-quarters-width}]

[start=3]
. このサンプルでは3つの状態を使いたいので、状態をもう2つ追加する（ <<add_stm_sample06>> ）。
** 「ST1」、「ST2」を追加した。

[[add_stm_sample06]]
.新しい状態に状態名をつけた
image::GSW-20220213-111820.png[{three-quarters-width}]

[start=3]
. 開始疑似状態、終了疑似状態を追加した（ <<add_stm_sample07>> ）。


[[add_stm_sample07]]
.開始疑似状態、終了疑似状態を追加した
image::GSW-20220213-112341.png[{three-quarters-width}]


==== ステートマシン図に状態遷移を追加する

状態が追加できたので、こんどは状態遷移を追加しましょう。
ステートマシン図には、通常の状態のほかにいくつかの「疑似状態」が登場します。
たとえば、「開始疑似状態」は、この図における最初の状態を示すのに使います。
「終了疑似状態」は、その図における最後の状態（1つとは限りません）を示すのに使います。

[[add_stm_trans00]]
.状態遷移を追加する
. パレットから「遷移」を選択して、「開始疑似状態」の内部へマウスカーソルを移動し、青枠が表示されるのを待つ（ <<add_stm_trans01>> ）。

[[add_stm_trans01]]
.開始疑似状態の内側で青枠を表示させる
image::add_stm_transition_58.png[{three-quarters-width}]

[start=2]
. 青枠が表示されたらマウスカーソルをドラッグする（マウスのボタンを押したままマウスカーソルを移動する）。
. マウスカーソルを「ST0」へドラッグして青枠が表示されるのを待つ（ <<add_stm_trans02>> ）。

[[add_stm_trans02]]
.「ST0」へマウスカーソルをドラッグして青枠が表示されるのを待つ
image::add_stm_transition_73.png[{three-quarters-width}]

[start=4]
. 「ST0」でも青枠が表示されたらマウスのボタンを離すと状態遷移が引かれる（ <<add_stm_trans03>> ）。

[[add_stm_trans03]]
.「ST0」でも青枠が表示されたらマウスのボタンを離すと状態遷移が引かれる
image::add_stm_transition_81.png[{three-quarters-width}]

[start=4]
. ほかの状態についても <<add_stm_trans04>> と同じように状態遷移を追加する。

[[add_stm_trans04]]
.ほかの状態遷移も追加する
image::add_stm_transition_215.png[{three-quarters-width}]

==== 状態とイベントと状態遷移の関係

===== 状態とイベント

ステートマシン図において、状態は「イベント」の発生を待っているところです。
多くの場合、イベントは、そのクラス自身の操作では処理を先に進められなくなるようなできごとです。
たとえば、外部からの入力（操作待ちや受信待ちなど）や、一定の時間経過などがイベントの候補になります。

===== 状態遷移

状態遷移は、ある状態において待っていたイベントが発生して、別の状態へ移ることを表しています。
イベントには、イベントが発生したとき、実際に遷移するか判定する条件を追加できます。
この条件のことを「ガード条件」と呼びます。
ガード条件つきのイベントでは、イベントが発生したときにガード条件を評価し、条件が真なら状態遷移します。
ガード条件が偽のとき、イベントは起きたことになります（消費されると呼びます）が、状態は遷移しません。

そして、状態遷移には、イベントが発生したときに実行したい処理を追加できます。
この処理のことを「アクション（またはエフェクト）」と呼びます。

イベントが発生すると、ガード条件つきのイベントならさらにガード条件も真なら、状態遷移に伴うアクションが実行され、それから次の状態へ遷移します。

==== ステートマシン図にイベントやアクションを追加する

まず、「ST0」から「ST1」への状態遷移を、イベントが「ev1」でガード条件は「gd（が真）」のとき、アクション「act1」を実行するよう編集してみましょう。

[[add_evt_act00]]
.状態遷移にイベントやアクションを追加する（１）
. 「ST0」から「ST1」への状態遷移を選択し、この遷移のプロパティーを表示し、ベースタブを開く。
.  プロパティーを編集する（ <<add_evt_act01>> ）。
** 「トリガー」にイベント名を設定する。ここでは「ev1」というイベントを設定する。
** 「ガード」にガード条件を設定する。ここでは「gd1（が真）」を設定しする。
** 「アクション」にアクションを設定する。ここでは「act1」という処理があるとして、これを設定する。
*** act1は、2つの引数（イベントとパラメーター）を持つメソッドと想定する。

[[add_evt_act01]]
.「ST0」から「ST1」への状態遷移のイベントとアクションを編集する
image::GSW-20220215-071155.png[{three-quarters-width}]

次に、「ST1」からの「ST2」への遷移です。
この遷移に割り当てるイベントは、「ev2」、アクションを「act2」とします。
そして、このアクションの実行後、ガード条件「gd2」が真なら「ST2」へ、偽ならアクション「act3」を実行してから「ST1」へ遷移するように変更してみます。

遷移先が2つあるなら、状態遷移を別々に引けばよさそうです。
ところが、同じイベントを待ってる遷移先が2つ以上あると、どちらの状態へ遷移するのか決定できなくなります（あいまいな状態遷移と呼びます）。
そこで、1つのイベントによる遷移先が状況によって変わる場合には「選択疑似状態」を使います。

[[add_evt_act02]]
.状態遷移にイベントやアクションを追加する（２）
. パレットから「選択疑似状態」を選択し、ステートマシン図に追加する（ <<add_evt_act03>> ）。


[[add_evt_act03]]
.「選択疑似状態」をステートマシン図に追加する
image::add_stm_trans45.png[{three-quarters-width}]

[start=2]
. 「ST1」から「ST2」への状態遷移を選択し、「ST2」側のハンドル（丸印）をマウスでつまみ、「選択疑似状態」へつなぎ直す（ <<add_evt_act04>> ）。

[[add_evt_act04]]
.既存の状態遷移を追加した「選択疑似状態」へつなぎ直す
image::add_stm_trans120.png[{three-quarters-width}]

[start=3]
. 「選択疑似状態」から「ST0」と「ST2」への状態遷移を追加する（ <<add_evt_act05>> ）。

[[add_evt_act05]]
.「選択疑似状態」から「ST0」と「ST2」への状態遷移を追加する
image::add_stm_trans218.png[{three-quarters-width}]

[start=4]
.  それぞれの遷移のプロパティーを編集する（ <<add_evt_act06>> ）。
** トリガーに「ev2」、ガード条件はなし、アクションを「act2」に設定する。
** ガードにガード条件「!gd2（gd2ではない）」、アクションを「act3」に設定する。
** ガードにガード条件「gd2」に設定する。

[[add_evt_act06]]
.状態遷移のイベントとアクションを編集する
image::add_stm_trans589.png[{three-quarters-width}]

[start=5]
. 同様にして、もう2つほど状態遷移を追加する（ <<add_evt_act07>> ）。


[[add_evt_act07]]
.さらに状態遷移とイベントとアクションを追加した
image::GSW-20220216-045358.png[{three-quarters-width}]

==== ステートマシン図に対応するコードを作成する

ステートマシン図ができたので、この図に合うようなRubyのコードを作成すルールを考えましょう。


===== 状態を保持する変数を追加する

まず、「Sample」クラスに状態を保持するインスタンス変数を追加します（ <<ruby_sample02>> ）。
初期値は、最初の状態（ ST0 ）にします。

[[ruby_sample02]]
.【Ruby】状態を保持するインスタンス変数を追加する
//[example]
//--
[source,ruby]
----
class Sample
  def initialize
    @state = :ST0 # <1>
    @attr_a = true
    @attr_b = true
  end

  # 略

end
----
<1> 現在の状態を保持する変数を用意し、 ST0 で初期化する。「 :ST0 」はRubyのシンボルの表記法。シンボルは名前付きの数値定数。
//--

===== 状態遷移を担当するメソッドを作成する

ステートマシン図に書いた状態遷移を担当する操作「play」をplayメソッドとして作成します（ <<ruby_sample03>> ）。
ルールの検討用なので、途中には処理の確認用の表示処理を書いておきます。

[[ruby_sample03]]
.【Ruby】状態遷移を担当するメソッドを作成する
//[example]
//--
[source,ruby]
----
class Sample
  def initialize
    # 略
  end

  def play(evt, param)
    puts "#{@state} ->" # <1>
    puts "  event:#{evt}, param: #{param}" # <2>
    case @state # <3>
    when :ST0
      st0_proc(evt, param) # <4>
    when :ST1
      st1_proc(evt, param)
    when :ST2
      # none
    end
    puts "       -> #{@state}" # <5>
    puts 'finished.' if @state == :ST2 # <6>
  end
end
----
<1> 遷移前の状態を表示する。
<2> イベントとパラメーターを表示する。
<3> 状態ごとの処理を case文を使って分岐する。
<4> 状態ごとの詳細な処理を担当するメソッドを呼び出す（ここでは st0_proc） 。
<5> 遷移後の状態を表示する。
<6> 終了状態になったことを知らせる。
//--

===== ガード条件の判定用メソッドを作成する

このサンプルのステートマシン図には、状態遷移のガード条件として「gd1」「gd2」が登場します。
これらをrubyのメソッドとして作成します。
rubyでは、真偽値を返すメソッドには「?」をつける習慣がありますので、これにしたがってメソッド名は「gd1?」「gd2?」とします。
サンプルとして、属性の値を使った演算を割り当てました（ <<ruby_sample04>> ）。

[[ruby_sample04]]
.【Ruby】ガード条件のメソッドを作成する
//[example]
//--
[source,ruby]
----
class Sample
  def initialize
    # 略
  end

  def play
    # 略
  end

  def gd1? # <1>
    @attr_a && @attr_b # <2>
  end

  def gd2? # <3>
    !@attr_a || @attr_b
  end
end
----
<1> 「gd1」用のメソッド。真偽値を返すメソッドに「?」をつけるRubyの習慣に倣った。
<2> 属性値を使った条件式の例。
<3> 「gd2」用のメソッド。
//--


===== 状態遷移を追加する（１）

状態ごとの処理を受け持つメソッドを作成します。
メソッド名は、状態名を小文字して「_proc」をつけるというルールにします。
したがって、状態名「ST0」の場合、メソッド名は「st0_proc」になります（ <<ruby_sample05>> ）。

[[ruby_sample05]]
.【Ruby】「ST0」の状態遷移のメソッドを作成する
//[example]
//--
[source,ruby]
----
class Sample
  def initialize
    # 略
  end

  def play
    # 略
  end

  def st0_proc(evt, param)
    case evt # <1>
    when :ev1 # <2>
      if gd1? # <3>
        puts "    gd1: #{gd1?}"
        act1(evt, param) # <4>
        @state = :ST1 # <5>
      else # <6>
        puts "    <<< gd1: #{gd1?}, transition is ignored. >>>"
      end
    when :ev3 # <7>
      act3(evt, param)
      @state = :ST2
    end
  end

  # gd1?, gd2? が続く
end
----
<1> イベントで場合分けする。
<2> イベントが「ev1」の場合。イベントはRubyのシンボルを使って表す。
<3> ガード条件による判定。
<4> アクション「act1」の呼び出し。
<5> 次の状態「ST1」への遷移。
<6> ガード条件が偽だったとき。イベントが無視されたことを表示する。
<7> イベントが「ev3」の場合。
//--

この部分のRubyのコードとステートマシン図の対応を図で表してみましょう（ <<ruby_sample06>> ）。

[[ruby_sample06]]
.Rubyのコードとステートマシン図の対応関係（１）
image::ruby_sample05.png[{full-width}]

おおむねのことは <<ruby_sample06>> を読めばわかるでしょうが、対応関係を説明しておきます。

[sidebar]
.ガード条件のある状態遷移をRubyのコードで表すルール
--
. 遷移元の状態で待っているイベントごとに場合分けする。
. ガード条件なしのときは（アクションがあればそれを呼び出して）、次の状態へ遷移する。
. ガード条件があるときは、先にガード条件を評価して、真であればアクションを実行して次の状態へ遷移する。
. ガード条件が偽のときは、アクションは実行されず、状態も遷移しない。
--

===== 状態遷移を追加する（２）

こんどは、「ST1」からの状態遷移に対するメソッド「st1_proc」です（ <<ruby_sample07>> ）。

[[ruby_sample07]]
.【Ruby】「ST1」の状態遷移のメソッドを作成する
//[example]
//--
[source,ruby]
----
class Sample
  def initialize
    # 略
  end

  def play
    # 略
  end

  def st0_proc(evt, param)
    # 略
  end

  def st1_proc(evt, param)
    case evt
    when :ev2 # <1>
      act2(evt, param) # <2>
      puts "    gd2: #{gd2?}"
      if gd2? # <3>
        @state = :ST2 # <4>
      else
        act3(evt, param) # <5>
        @state = :ST0 # <6>
      end
    when :ev3 # <7>
      act3(evt, param)
      @state = :ST0
    end
  end

  # gd1?, gd2? が続く
end
----
<1> イベントが「ev2」の場合。
<2> アクション「act2」の呼び出し。
<3> 選択疑似状態におけるガード条件による判定。
<4> 次の状態「ST0」への遷移。
<5> 選択疑似状態からの遷移におけるアクション「act3」の呼び出し。
<6> 次の状態「ST2」への遷移。
<7> イベントが「ev3」の場合。
//--

この部分のRubyのコードとステートマシン図の対応を図で表してみましょう（ <<ruby_sample08>> ）。

[[ruby_sample08]]
.Rubyのコードとステートマシン図の対応関係（２）
image::ruby_sample08.png[{full-width}]


おおむねのことは <<ruby_sample08>> を読めばわかるでしょうが、対応関係を説明しておきます。

[sidebar]
.選択疑似状態がある状態遷移をRubyのコードで表すルール
--
. 選択疑似状態の前の状態遷移については、<<ruby_sample06>> のルールで賄う。
. その後で、選択疑似状態の後の状態遷移のガード条件を評価する。
. 評価結果によって（アクションがあれば実行してから）、次の状態へ遷移する。
. 選択疑似状態の後の状態遷移は、ガード条件による場合分けで漏れる場合がないように注意する。
--

このサンプルでは、アクション「act1」、「act2」、「act3」は、定めたルールを確認しやすいメソッドにしておきます（ <<ruby_sample09>> ）。
これらのアクションと、先に挙げたガード条件をチェックするメソッドは、「Sample」クラス内部のメソッドだけが使います。そこで、Rubyのコードでもこれらのメソッドのスコープを「private」にしましょう。Rubyでは、「private」キーワードを追加してその後にメソッドを配置します。

[[ruby_sample09]]
.【Ruby】「ST1」の状態遷移のメソッドを作成する
//[example]
//--
[source,ruby]
----
class Sample
  # initialize、play、st0_proc、st1_proc の定義を省略

  praivate # <1>

  def act1(evt, prm)
    puts "     act1: event:#{evt}, param: #{prm}"
  end

  def act2(evt, prm)
    puts "     act2: event:#{evt}, param: #{prm}"
  end

  def act3(evt, prm)
    puts "     act3: event:#{evt}, param: #{prm}"
  end

  def gd1? # <2>
    @attr_a && @attr_b
  end

  def gd2?
    !@attr_a || @attr_b
  end
end
----
<1> この宣言以降のメソッドは、可視性が「private」なメソッドになる。
<2> ガード条件の判定用メソッドも「private」なメソッドに含めた。
//--

これで、ステートマシン図で表したクラスの振る舞いをRubyのコードに対応づけられました。

==== 追加したアクションをクラス図に反映する

ステートマシン図を作成するときに追加したアクションは、このステートマシン図を割り当てているクラス（ここでは「Sample」クラス）の操作にしておきましょう。
ここで、「Sample」クラスをテストするクラス「SampleTest」も追加しておきます。

[[update_sample_class00]]
.イベントやアクションをクラス図に反映する
. クラス図を開く。
. 「Sample」クラスを選択し、プロパティーから「操作」タブを表示する。
. 「＋」アイコンを使って操作「act1」を追加する。
. 可視性を「private」に設定する。
. 「act2」、「act3」についても同じように設定する（ <<update_sample_class01>> ）。

[[update_sample_class01]]
.「Sample」クラス内部で使う操作「act1、「act2」「act3」を追加する
image::GSW-20220216-050914.png[{three-quarters-width}]

[start=6]
. ガード条件に使うメソッド「gd1?」「gd2?」も追加しておく。
. 「SampleTest」クラスを追加する（ <<update_sample_class02>> ）。
** このテスト用クラスには、テストを実行する「run」メソッドを用意しておく。
** テスト用のメソッドをいくつか追加しておく。
. 「SampleTest」から「Sample」クラスへ関連を引き、関連端名を「samp01」、多重度を「1」としておく。


[[update_sample_class02]]
.「SampleTest」クラスと関連を追加する
image::GSW-20220224-113632.png[{three-quarters-width}]


これで、クラス図とステートマシン図とRubyのコードの対応づけができました。
実際の問題について、クラス図やステートマシン図を作成するときは、このようなルールを使う前提で作成します。
そして、Rubyでコードを作成するときは、作成した図と対網づけのルールを使ってコードを作成します。


.【参考】列挙型（enum）をクラス図に反映する方法について
****
Rubyにはenumのような列挙子を直接定義する方法がないので、このチュートリアルの簡単のために、状態を表す定数を定義するために「シンボル（:ST0など）」を使いました。

{astah} は、Java, C#、C++ については、enumを設定する方法を提供していますので、その方法で代用してもよいでしょう。

詳しい設定方法については、次の記事を参考にしてみてください。

Java、enumの設定:: `http://astah-users.change-vision.com/ja/modules/xhnewbb/viewtopic.php?topic_id=1249`
****


=== 変換ルールを使ったコードを確認する

検討用のクラス図とステートマシン図に対応づけたRubyのプログラムの動作を確認してみましょう。

==== 検討用モデルに対応したRubyプログラムの全体

作成したプログラムの全体を <<ruby_sample_code01>>  に示します。
このプログラムのコードには、「SampleTest」のインスタンスを作成して、テストを起動する処理や、テストメソッドの具体例が含まれています。
テストクラスやテスト用メソッドの細かい説明は省きます。

[[ruby_sample_code01]]
.【Ruby】stm_sample.rb
//[example]
//--
[source,ruby,linenums]
----
include::{sourcesdir}/stm_sample.rb[]
----
<1> 文字列の破壊的変更の検出を指示するマジックコメント。
<2> 簡便にテストするために、アクセサーを追加した（あくまでこのサンプルにおける便宜として）。
<3> Sampleクラスのメソッドを呼び出すテストを定義したテスト用のクラスの定義。
<4> テスト用クラスを実行するコード。このブロックはファイル名と実行プログラム名が一致するときに有効になる（そのときだけ実行される）。
//--

==== 検討用モデルに対応したRubyプログラムを動かす

コマンドプロンプトを起動して（MacやLinuxならターミナルを起動して）、プログラムを実行してみます（ <<ruby_sample_code02>> ）。

動作させると、状態遷移やイベントが表示されます。
作成したモデル図を比較して期待した動作をしているか確認してみましょう。


[[ruby_sample_code02]]
.【端末】stm_sample.rb を実行する
//[example]
//--
[source,console]
----
C:\Users\kuboaki>cd Desktop\BowlingScore

C:\Users\kuboaki\Desktop\BowlingScore>ruby stm_sample.rb
ST0 ->
  event:ev1, param: 676481
    gd1: true
     act1: event:ev1, param: 676481
       -> ST1
ST1 ->
  event:ev2, param: 678623
     act2: event:ev2, param: 678623
    gd2: true
       -> ST2
finished.
================
ST0 ->
  event:ev1, param: 680596
    <<< gd1: false, transition is ignored. >>>
       -> ST0
ST0 ->
  event:ev3, param: 681783
     act3: event:ev3, param: 681783
       -> ST2
finished.
================
ST0 ->
  event:ev1, param: 683477
    <<< gd1: false, transition is ignored. >>>
       -> ST0
ST0 ->
  event:ev2, param: 685784
       -> ST0
ST0 ->
  event:ev3, param: 708214
     act3: event:ev3, param: 708214
       -> ST2
finished.
================

C:\Users\kuboaki\Desktop\BowlingScore>
----
//--



=== まとめ

クラス図とステートマシン図で動作を表現すれば、Rubyのコードに変換できることがわかりました。

==== 構造のモデルを作成した手順

構造のモデルに登場する構成要素や要素間の関連を見つけ出し、スコアシートの構造を整理しました。

[[step_for_structure_model02]]
.スコアシートの構造のモデルを作成した手順
[sidebar]
--
. スコアシートに関する構成要素の発見
** 具体的なスコアシートを観察して、そこにある要素を洗い出してオブジェクト図で表した。
. スコアシートに関するクラス図の作成
** オブジェクト図に登場したオブジェクトからクラスを、オブジェクト同士のリンクから関連を見出し、クラス図に表した。
--

==== 構造のモデルだけではプログラムは作れない

構造のモデルを作ったことで、プログラムを構成する要素と、要素同士の関係（関連）を表せるようになりました。
また、クラスのインスタンスをオブジェクト図に見合うように作成すれば、実際に観察したスコアシートと同じようなデータ構造を作成できることもわかりました。

ところで、作りたかったのは、ボウリングのゲームスコアをつけるプログラムでした。
つまり、プレーヤーがフレームごとに交代して投球し、そのたびにスコアを更新する処理です。
ですが、これまでに作成した構造のモデルでは、ゲームの進行に応じてどんなことを処理するか表せていません。
そのためには、処理の中身を表す「振る舞いのモデル」を作成する必要があります。
次の章では、ステートマシン図を使って、フレームやスコアの振る舞いを表すモデルを作成します。
