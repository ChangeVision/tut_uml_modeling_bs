ifndef::revnumber[]
include::front_matter.adoc[]
endif::[]

[[_model_to_code_design]]
== モデルとコードの対応づけ

[.lead]
プログラムがどのように動作するのか検討するときには、振舞いのモデルを使います。
振舞いのモデルを作成する前に、構造のモデルと振舞いのモデルがどのようなコードとして実現されるのかについて、このチュートリアルで用いる方式を決めておきましょう。
このことを「モデルとコードの対応づけ」と呼ぶことにします。

TIP: このような対応づけを「モデル変換ルール」と呼ぶこともあります。また、開発プロセスのなかでこの対応づけを検討する「方式設計」と呼ぶ人もいます。

モデルとコードの対応づけを決めてそれを前提にして設計する（モデルを作る）ことは、実装に依存する情報と依存しない情報を分離することを促すため、実装に依存しないモデルを作るのに役立ちます。


=== 対応づけ検討用モデルの作成


このチュートリアルでは実装にRubyを使うことにしました。
そこで、対応づけの方式を検討するために、サンプルモデルとサンプルモデルに対応するRubyプログラムを作ってみましょう。

==== 対応づけ検討用プロジェクトを用意する

「モデルとコードの対応づけ」の検討用に、{astah} で別のプロジェクトを作成しましょう。

.対応づけ検討用プロジェクトを作成する
[example]
--
. {astah} で新規プロジェクトを作成する。
. 作成したプロジェクトをいったん保存する。
** モデルファイルの名前は「stm_sample.asta」とする。
--

プロジェクトが保存できたら、プロジェクトにクラス図を追加します（ <<add_stm_sample_class_diag>> ）。


[[add_stm_sample_class_diag]]
.対応づけ検討用プロジェクトにクラス図を用意する
[example]
--
. 構造ツリーで、プロジェクト名をクリックしてポップアップメニューを開く。
. 「図の追加＞クラス図」でクラス図を追加する。
. プロパティから、クラス図の名前を「クラス図」に変更する。

[[add_stm_sample00]]
.対応づけの説明に使うプロジェクトにクラス図を追加した
image::GSW-20220213-005309.png[{half-width}]
--

対応づけの説明用に、簡単なクラス「Sample」の定義から始めましょう。
このクラスは、操作「Play」と属性「attr_a」「attr_b」を持つクラスとします。
これをUMLのクラスとして表してみましょう（ <<add_sample_class00>> ）。

[[add_sample_class00]]
.クラス図に「Sample」クラスを追加する
[example]
--
. パレットからクラスを選択し、クラス図に追加する。
. クラス名を「Sample」にする（ <<sample_class01>> ）。
** クラスに操作「play」を追加する。
** クラスに属性「attr_a」「attr_b」を追加する。

[[sample_class01]]
.クラス図に「Sample」クラスを追加した
image::GSW-20220212-220754.png[{three-quarters-width}]
--


これをRubyのコードで表すと <<ruby_sample01>> のようになります。

[[ruby_sample01]]
.「Sample」クラスを表すRubyのコード
[example]
--
[source,ruby]
----
class Sample
  def initialize
    @attrs_a = true
    @attrs_b = true
  end

  def play
  end
end
----
--

==== クラスにステートマシン図を追加する

このサンプルにおいては、いま追加した操作「play」が、「Sample」クラスの振舞いを提供しているとします。
しかし、クラス図に描いた「Sample」クラスに操作「play」を追加しただけでは、その処理内容はわかりません。
どこかに「play」の処理内容を表した図が必要です。

そこで、「Sample」クラスに対して、操作「play」の振舞いを表すステートマシン図を追加します（ <<add_stm_sample01>> ）。
ここで、図を追加する対象を「Sample」クラスにしているのは、このステートマシン図が「Sample」クラスの振舞いのモデル図であるとわかるようにするためです。

[[add_stm_sample01]]
.「Sample」クラスにステートマシン図を追加する
[example]
--
. 構造ツリーから「Sample」クラスを選択し、右クリックしてポップアップメニューを表示する（ <<add_stm_sample02>> ）。


[[add_stm_sample02]]
.「Sample」クラスにステートマシン図を追加する
image::GSW-20220213-020944.png[{three-quarters-width}]


[start=2]
. 「図の追加＞ステートマシン図」でステートマシン図が追加される。
** プロパティから図の名前を編集し、「Sampleのplayのステートマシン図」とする（ <<add_stm_sample03>> ）。
** ダイアグラムエディタのタイトルやタブにも反映される。

[[add_stm_sample03]]
.追加したステートマシン図に名前をつけた。
image::GSW-20220213-013034.png[{three-quarters-width}]
--

.ステートマシン図を学ぶチュートリアル
****
ここでは、モデルとコードの対応づけを説明するために、振舞いのモデルの一種であるステートマシン図を作成しています。
ステートマシン図を使って振舞いを設計する方法については、次のチュートリアルも参考にしてみてください。

ステートマシン図 & 状態遷移表チュートリアル:: `https://www.changevision.co/tutorial-statemachine-japanese.html`
****

==== ステートマシン図に状態を追加する

次に、追加したステートマシン図に、状態を追加します。

.ステートマシン図に状態を追加する
[example]
--
. パレットから「状態」を選択し、ステートマシン図に状態を追加する。
** 追加した状態の状態名は「状態0」（数字は追加の都度変わる）となっている（ <<add_stm_sample04>> ）。

[[add_stm_sample04]]
.新しい状態を追加した
image::GSW-20220213-093229.png[{three-quarters-width}]

[start=2]
. 「状態0」を選択し、プロパティの「ベース」タブの「名前」を編集して、状態の名前を「ST0」にする（ <<add_stm_sample05>> ）。
** 状態「ST0」は、このサンプルの例示用に使う状態名のひとつ。

[[add_stm_sample05]]
.新しい状態に状態名をつけた
image::GSW-20220213-104448.png[{three-quarters-width}]

[start=3]
. このサンプルでは3つの状態を使いたいので、状態をもう2つ追加する（ <<add_stm_sample06>> ）。
** 「ST1」、「ST2」を追加した。

[[add_stm_sample06]]
.新しい状態に状態名をつけた
image::GSW-20220213-111820.png[{three-quarters-width}]

[start=3]
. 開始疑似状態、終了疑似状態を追加した（ <<add_stm_sample07>> ）。


[[add_stm_sample07]]
.開始疑似状態、終了疑似状態を追加した
image::GSW-20220213-112341.png[{three-quarters-width}]
--


==== ステートマシン図に状態遷移を追加する

状態が追加できたので、こんどは状態遷移を追加しましょう。
ここで、開始疑似状態は、この図における最初の状態を示すのに使います。
終了疑似状態は、その図における最後の状態（ひとつとは限りません）を示すのに使います。

[[add_stm_trans00]]
.状態遷移を追加する
[example]
--
. パレットから「遷移」を選択して、「開始疑似状態」の内部へマウスカーソルを移動し、青枠が表示されるのを待つ（ <<add_stm_trans01>> ）。

[[add_stm_trans01]]
.開始疑似状態の内側で青枠を表示させる
image::add_stm_transition_58.png[{three-quarters-width}]


[start=2]
.青枠が表示されたらマウスのボタンを押したままマウスカーソルを移動する（ <<add_stm_trans02>> ）。

[[add_stm_trans02]]
.青枠が表示されたらマウスのボタンを押したままマウスカーソルをドラッグする
image::add_stm_transition_73.png[{three-quarters-width}]

[start=3]
.青枠が表示されたらマウスのボタンを押したままマウスカーソルを移動する（ <<add_stm_trans03>> ）。

[[add_stm_trans03]]
.「ST0」でも青枠が表示されたらマウスのボタンを離す
image::add_stm_transition_81.png[{three-quarters-width}]

[start=4]
.ほかの状態についても <<add_stm_trans04>> と同じように状態遷移を追加する。

[[add_stm_trans04]]
.ほかの状態遷移も追加する
image::add_stm_transition_215.png[{three-quarters-width}]


--


==== ステートマシン図にイベントやアクションを追加する

ステートマシン図において、状態は「イベント」の発生を待っているところです。
多くの場合、イベントは、そのクラス自身の操作では処理を先に進められなくなるようなできごとです。
たとえば、外部からの入力（操作待ちや受信待ちなど）や、一定の時間経過などがイベントの候補になります。

状態遷移は、ある状態において待っていたイベントが発生して、別の状態へ移ることを表しています。
イベントには、イベントが発生したとき、実際に遷移するか判定する条件を追加できます。
この条件のことを「ガード条件」と呼びます。
ガード条件つきのイベントでは、イベントが発生したときにガード条件を評価し、条件が真なら状態遷移します。
ガード条件が偽のとき、イベントは起きたことになります（消費されると呼びます）が、状態は遷移しません。

そして、状態遷移には、イベントが発生したときに実行したい処理を追加できます。
この処理のことを「アクション（またはエフェクト）」と呼びます。

イベントが発生すると、ガード条件つきのイベントならさらにガード条件も真なら、状態遷移に伴うアクションが実行され、それから次の状態へ遷移します。
まず、「ST0」から「ST1」への状態遷移を、イベントが「ev1」でガード条件は「gd（が真）」のとき、アクション「act1」を実行するよう編集してみましょう。

[[add_evt_act00]]
.状態遷移にイベントやアクションを追加する（１）
[example]
--
. 「ST0」から「ST1」への状態遷移を選択し、この遷移のプロパティを表示し、ベースタブを開く。
.  プロパティを編集する（ <<add_evt_act01>> ）。
** 「トリガー」にイベント名を設定する。ここでは「ev1」というイベントを設定する。
** 「ガード」にガード条件を設定する。ここでは「gd1（が真）」を設定しする。
** 「アクション」にアクションを設定する。ここでは「act1」という処理があるとして、これを設定する。
*** act1は、2つの引数（イベントとパラメータ）を持つメソッドと想定する。

[[add_evt_act01]]
.「ST0」から「ST1」への状態遷移のイベントとアクションを編集する
image::GSW-20220215-071155.png[{three-quarters-width}]

--

次に、「ST1」からの「ST2」への遷移です。
この遷移に割り当てるイベントは、「ev2」、アクションを「act2」とします。
そして、このアクションの実行後、ガード条件「gd2」が真なら「ST2」へ、偽ならアクション「act3」を実行してから「ST1」へ遷移するように変更してみます（ <<add_evt_act02>> ）。

遷移先が2つあるなら、状態遷移を別々に引けばよさそうです。
ところが、同じイベントを待っていてる遷移先が2つ以上あると、どちらの状態へ背にするのか決定できなくなります（あいまいな状態遷移と呼びます）。
そこで、1つのイベントによる遷移先が状況によって変わる場合には「選択疑似状態」を使います。

[[add_evt_act02]]
.状態遷移にイベントやアクションを追加する（２）
[example]
--
. パレットから「選択疑似状態」を選択し、ステートマシン図に追加する（ <<add_evt_act03>> ）。


[[add_evt_act03]]
.「選択疑似状態」をステートマシン図に追加する
image::add_stm_trans45.png[{three-quarters-width}]


[start=2]
. 「ST1」から「ST2」への状態遷移を選択し、「ST2」側のハンドル（丸印）をマウスでつまみ、「選択疑似状態」へつなぎ直す（ <<add_evt_act04>> ）。

[[add_evt_act04]]
.既存の状態遷移を追加した「選択疑似状態」へつなぎ直す
image::add_stm_trans120.png[{three-quarters-width}]

[start=3]
. 「選択疑似状態」から「ST0」と「ST2」への状態遷移を追加する（ <<add_evt_act05>> ）。

[[add_evt_act05]]
.「選択疑似状態」から「ST0」と「ST2」への状態遷移を追加する
image::add_stm_trans218.png[{three-quarters-width}]

[start=4]
.  それぞれの遷移のプロパティを編集する（ <<add_evt_act06>> ）。
** トリガーに「ev2」、ガード条件はなし、アクションを「act2」に設定する。
** ガードにガード条件「!gd2（gd2ではない）」、アクションを「act3」に設定する。
** ガードにガード条件「gd2」に設定する。

[[add_evt_act06]]
.状態遷移のイベントとアクションを編集する
image::add_stm_trans589.png[{three-quarters-width}]

[start=5]
. 同様にして、あと2つほど状態遷移を追加する（ <<add_evt_act07>> ）。


[[add_evt_act07]]
.さらに状態遷移とイベントとアクションを追加した
image::GSW-20220216-045358.png[{three-quarters-width}]
--

==== ステートマシン図に対応するコードを作成する

ステートマシン図ができたので、この図に合うようなRubyのコードを作成すルールを考えましょう。


===== 状態を保持する変数を追加する

まず、「Sample」クラスに状態を保持するインスタンス変数を追加します（ <<ruby_sample02>> ）。
初期値は、最初の状態（ ST0 ）にします。

[[ruby_sample02]]
.状態を保持するインスタンス変数を追加する
[example]
--
[source,ruby]
----
class Sample
  def initialize
    @state = :ST0 # <1>
    @attrs_a = true
    @attrs_b = true
  end

  # 略

end
----
<1> 現在の状態を保持する変数を用意し、 ST0 で初期化する。「 :ST0 」はRubyのシンボルの表記法。シンボルは名前付きの数値定数。
--

===== 状態遷移を担当するメソッドを作成する

ステートマシン図に書いた状態遷移を担当する操作「play」をPlayメソッドとして作成します（ <<ruby_sample03>> ）。
ルールの検討用なので、途中には処理の確認用の表示処理を書いておきます。

[[ruby_sample03]]
.状態遷移を担当するメソッドを作成する
[example]
--
[source,ruby]
----
class Sample
  # 略

  def play(evt, param)
    puts "#{@state} ->" # <1>
    puts "  event:#{evt}, param: #{param}" # <2>
    case @state # <3>
    when :ST0
      st0_proc(evt, param) # <4>
    when :ST1
      st1_proc(evt, param)
    when :ST2
      # none
    end
    puts "       -> #{@state}" # <5>
    puts 'finished.' if @state == :ST2 # <6>
  end

  # 略
end
----
<1> 遷移前の状態を表示する。
<2> イベントとパラメータを表示する。
<3> 状態ごとの処理を case文を使って分岐する。
<4> 状態ごとの詳細な処理を担当するメソッドを呼び出す（ここでは st0_proc） 。
<5> 遷移後の状態を表示する。
<6> 終了状態になったことを知らせる。
--

===== ガード条件の判定用メソッドを作成する

このサンプルのステートマシン図には、状態遷移のガード条件として「gd1」「gd2」が登場します。
これらをメソッドとして作成します。
サンプルとして、属性の値を使った演算を割り当てました（ <<ruby_sample04>> ）。

[[ruby_sample04]]
.ガード条件のメソッドを作成する
[example]
--
[source,ruby]
----
class Sample
  # 略

  def gd1? # <1>
    @attr_a && @attr_b # <2>
  end

  def gd2? # <3>
    !@attr_a || @attr_b
  end

  # 略
end
----
<1> 「gd1」用のメソッド。Rubyでは、真偽値を返すメソッドに「?」をつけることがある。
<2> 属性値を使った条件式の例。
<3> 「gd2」用のメソッド。
--


===== 状態遷移を追加する（１）

状態ごとの処理を受け持つメソッドを作成します。
まず、「ST0」からの状態遷移に対するメソッド「st0_proc」です（ <<ruby_sample05>> ）。

[[ruby_sample05]]
.「ST0」の状態遷移のメソッドを作成する
[example]
--
[source,ruby]
----
class Sample
  # 略

  def st0_proc(evt, param)
    case evt # <1>
    when :ev1 # <2>
      if gd1? # <3>
        puts "    gd1: #{gd1?}"
        act1(evt, param) # <4>
        @state = :ST1 # <5>
      else # <6>
        puts "    <<< gd1: #{gd1?}, transition is ignored. >>>"
      end
    when :ev3 # <7>
      act3(evt, param)
      @state = :ST2
    end
  end

  # 略
end
----
<1> イベントで場合分けする。
<2> イベントが「ev1」の場合。イベントはRubyのシンボルを使って表す。
<3> ガード条件による判定。
<4> アクション「act1」の呼び出し。
<5> 次の状態「ST1」への遷移。
<6> ガード条件が偽だったとき。イベントが無視されたことを表示する。
<7> イベントが「ev3」の場合。
--

この部分のRubyのコードとステートマシン図の対応を図で表してみましょう（ <<ruby_sample06>> ）。

[[ruby_sample06]]
.Rubyのコードとステートマシン図の対応関係（１）
image::ruby_sample05.png[{full-width}]

===== 状態遷移を追加する（２）

こんどは、「ST1」からの状態遷移に対するメソッド「st1_proc」です（ <<ruby_sample07>> ）。

[[ruby_sample07]]
.「ST1」の状態遷移のメソッドを作成する
[example]
--
[source,ruby]
----
class Sample
  # 略

  def st1_proc(evt, param)
    case evt
    when :ev2 # <1>
      act2(evt, param) # <2>
      puts "    gd2: #{gd2?}"
      if gd2? # <3>
        @state = :ST2 # <4>
      else
        act3(evt, param) # <5>
        @state = :ST0 # <6>
      end
    when :ev3 # <7>
      act3(evt, param)
      @state = :ST0
    end
  end

  # 略
end
----
<1> イベントが「ev2」の場合。
<2> アクション「act2」の呼び出し。
<3> 選択疑似状態におけるガード条件による判定。
<4> 次の状態「ST0」への遷移。
<5> 選択疑似状態からの遷移におけるアクション「act3」の呼び出し。
<6> 次の状態「ST2」への遷移。
<7> イベントが「ev3」の場合。
--

この部分のRubyのコードとステートマシン図の対応を図で表してみましょう（ <<ruby_sample08>> ）。

[[ruby_sample08]]
.Rubyのコードとステートマシン図の対応関係（２）
image::ruby_sample08.png[{full-width}]

アクション「act1」、「act2」、「act3」は、呼び出しされたときのイベントやパラメータが確認できる簡便なメソッドにしておきます（ <<ruby_sample09>> ）。
また、アクションとガード条件は、「Sample」クラス内部で使うメソッドなので、「private」なメソッドにしておきます。

[[ruby_sample09]]
.「ST1」の状態遷移のメソッドを作成する
[example]
--
[source,ruby]
----
class Sample
  # 略

  praivate # <1>

  def act1(evt, prm)
    puts "     act1: event:#{evt}, param: #{prm}"
  end

  def act2(evt, prm)
    puts "     act2: event:#{evt}, param: #{prm}"
  end

  def act3(evt, prm)
    puts "     act3: event:#{evt}, param: #{prm}"
  end

  def gd1? # <2>
    @attr_a && @attr_b
  end

  def gd2?
    !@attr_a || @attr_b
  end
end
----
<1> この宣言以降のメソッドは、可視性が「private」なメソッドになる。
<2> ガード条件の判定用メソッドも「private」なメソッドに含めた。
--

これで、ステートマシン図で表したクラスの振舞いをRubyのコードに対応づけらました。

==== 追加したアクション等をクラス図に反映する

ステートマシン図を作成するときに追加したアクションは、このステートマシン図を割り当てているクラス（ここでは「Sample」クラス）の操作にしておきましょう。
ここで、「Sample」クラスをテストするクラス「SampleTest」も追加しておきます。

[[update_sample_class00]]
.イベントやアクションをクラス図を更新する
[example]
--
. クラス図を開く。
. 「Sample」クラスクを選択し、プロパティから「操作」タブを表示する。
. 「＋」アイコンを使って操作「act1」を追加する。
. 可視性を「private」に設定する。
. 「act2」、「act3」についても同じように設定する。
. ガード条件に使うメソッド「gd1?」「gd2」も追加しておく（ <<update_sample_class01>> ）。

[[update_sample_class01]]
.「Sample」クラス内部で使う操作を追加する
image::GSW-20220216-050914.png[{three-quarters-width}]

[start=6]
. 「SampleTest」クラスを追加しておく（ <<update_sample_class02>> ）。
** このテスト用クラスには、テストを実行する「run」メソッドを用意しておく。
** テスト用のメソッドをいくつか追加しておく。
. 「SampleTest」から「Sample」クラスへ関連を引き、関連端名を「samp01」、多重度を「1」としておく。


[[update_sample_class02]]
.「SampleTest」クラスと関連を追加する
image::GSW-20220224-113632.png[{three-quarters-width}]

--

これで、クラス図とステートマシン図とRubyのコードの対応づけができました。
実際の問題について、クラス図やステートマシン図を作成するときは、このようなルールを使う前提で作成します。
そして、Rubyでコードを作成するときは、作成した図と対網づけのルールを使ってコードを作成します。


.列挙型（enum）をクラス図に反映する方法について
****
Rubyにはenumのような列挙子を直接定義する方法がないので、このチュートリアルの簡単のために、状態を表す定数を定義するために「シンボル（:ST0など）」を使いました。

{astah} は、Java, C#、C++ については、enumを設定する方法を提供していますので、その方法で代用してもよいでしょう。

詳しい設定方法については、次の記事を参考にしてみてください。

Java、enumの設定:: `http://astah-users.change-vision.com/ja/modules/xhnewbb/viewtopic.php?topic_id=1249`
****


=== 変換ルールを使ったコードを確認する

検討用のクラス図とステートマシン図に対応づけたRubyのプログラムの動作を確認してみましょう。

==== 検討用モデルに対応したRubyプログラムの全体

作成したプログラムの全体を <<ruby_sample_code01>>  に示します。
このプログラムのコードには、「SampleTest」のインスタンスを作成して、テストを起動する処理や、テストメソッドの具体例が含まれています。


[[ruby_sample_code01]]
.stm_sample.rb
[example]
--
[source,ruby,linenums]
----
include::{sourcesdir}/stm_sample.rb[]
----
--

==== 検討用モデルに対応したRubyプログラムを動かす

コマンドプロンプトを起動して（MacやLinuxならターミナルを起動して）、プログラムを実行してみます（ <<ruby_sample_code02>> ）。

[[ruby_sample_code02]]
.【端末】stm_sample.rb を実行する
[example]
--
[source,console]
----
C:\Users\kuboaki>cd Desktop\BowlingScore

C:\Users\kuboaki\Desktop\BowlingScore>ruby stm_sample.rb
ST0 ->
  event:ev1, param: 676481
    gd1: true
     act1: event:ev1, param: 676481
       -> ST1
ST1 ->
  event:ev2, param: 678623
     act2: event:ev2, param: 678623
    gd2: true
       -> ST2
finished.
================
ST0 ->
  event:ev1, param: 680596
    <<< gd1: false, transition is ignored. >>>
       -> ST0
ST0 ->
  event:ev3, param: 681783
     act3: event:ev3, param: 681783
       -> ST2
finished.
================
ST0 ->
  event:ev1, param: 683477
    <<< gd1: false, transition is ignored. >>>
       -> ST0
ST0 ->
  event:ev2, param: 685784
       -> ST0
ST0 ->
  event:ev3, param: 708214
     act3: event:ev3, param: 708214
       -> ST2
finished.
================

C:\Users\kuboaki\Desktop\BowlingScore>
----
--

動作させると、状態遷移やイベントが表示されますので、作成したモデル図を比較して期待した動作をしているか確認してみましょう。


=== まとめ

クラス図とステートマシン図で動作を表現すれば、Rubyのコードに変換できることがわかりました。



.モデル変換とモデル駆動開発（MDD）
****
ここで示したようなモデルとコードの対応づけのほかに、モデルから別のモデルへ、あるいはコードから別のコードへといった対応づけも考えられます。
これらは、ソフトウェア設計における「モデル変換」と呼ばれています（コードも一種のモデル表現とみなせます）。
そして、モデル変換を用いて開発プロセスにおける各工程間をモデルで接続して開発する方法のことを「モデル駆動開発（MDD: Model Driven Development）」と呼びます。

モデル駆動開発を紹介している記事として次の記事があります。

モデル駆動開発におけるモデル変換の役割:: `https://codezine.jp/article/detail/10597`

この記事では、モデル変換の繰り返しによる開発方法であることや、その実施例を紹介しています。
****


